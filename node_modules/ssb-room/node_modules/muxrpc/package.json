{
  "name": "muxrpc",
  "description": "combined multiplexing and rpc - because a node api needs streams & async",
  "version": "6.7.3",
  "homepage": "https://github.com/ssbc/muxrpc",
  "repository": {
    "type": "git",
    "url": "git://github.com/ssbc/muxrpc.git"
  },
  "files": [
    "*.js"
  ],
  "dependencies": {
    "debug": "^4.3.3",
    "clarify-error": "^1.0.0",
    "packet-stream": "~2.0.0",
    "packet-stream-codec": "^1.2.0",
    "pull-goodbye": "0.0.3",
    "pull-stream": "^3.6.10"
  },
  "devDependencies": {
    "c8": "^7.11.0",
    "cont": "~1.0.1",
    "json-buffer": "~2.0.9",
    "pull-abortable": "~4.1.0",
    "pull-pair": "~1.0.0",
    "pull-pushable": "^1.1.4",
    "pull-serializer": "~0.2.0",
    "standardx": "^7.0.0",
    "tap-bail": "^1.0.0",
    "tap-spec": "^5.0.0",
    "tape": "~5.2.2"
  },
  "author": "Dominic Tarr <dominic.tarr@gmail.com> (http://dominictarr.com)",
  "license": "MIT",
  "scripts": {
    "tape": "tape test/*.js | tap-bail | tap-spec",
    "test": "standardx '**/*.js' && npm run tape",
    "coverage": "c8 --reporter=lcov npm run tape",
    "test-verbose": "TEST_VERBOSE=1 npm test",
    "lint": "standardx --fix '**/*.js'"
  },
  "readme": "# muxrpc\n\ncombined rpc and multiplexing, with pull-streams.\n\n[![build status](https://secure.travis-ci.org/ssbc/muxrpc.png)](http://travis-ci.org/ssbc/muxrpc)\n\n\n## motivation\n\n`muxrpc` aims to provide remote access to any reasonable node.js api remotely.\nthis means it supports both streaming and async operations.\n[pull-streams](https://github.com/pull-stream/pull-stream) are used.\n\nIt may seem at first that it would be logically cleaner to separate this into two concerns,\nmultiplexing and request-response. Indeed, we did just that in [multilevel](https://github.com/juliangruber/multilevel)\ncombining [mux-demux](http://github.com/dominictarr/mux-demux) and [rpc-stream](http://github.com/dominictarr/rpc-stream)\nhowever, I realized that multiplexing depends on adding framing to incoming messages,\nand so does rpc. If rpc is implemented as another layer on top of multiplexing, then the rpc messages\nend up with a second layer of framing too. By implementing one protocol that supports both streams\nand rpc, we were able to have both features with only a single layer of framing.\n\n## example\n\n```js\nconst MRPC = require('muxrpc')\nconst pull = require('pull-stream')\nconst toPull = require('stream-to-pull-stream')\n\n//we need a manifest of methods we wish to expose.\nconst manifest = {\n  //async is a normal async function\n  hello: 'async',\n\n  //source is a pull-stream (readable)\n  stuff: 'source'\n\n  //TODO: sink and duplex pull-streams\n}\n\n//the actual methods which the server exposes\nconst api = {\n  hello(name, cb) {\n    cb(null, 'hello, ' + name + '!')\n  },\n  stuff() {\n    return pull.values([1, 2, 3, 4, 5])\n  }\n}\n\n//pass the manifests into the constructor, and then pass the local api object you are wrapping\n//(if there is a local api)\nconst client = MRPC(manifest, null) () //MRPC (remoteManifest, localManifest) (localApi)\nconst server = MRPC(null, manifest) (api)\n```\n\nnow set up a server, and connect to it...\n\n```js\nconst net = require('net')\n\nnet.createServer(stream => {\n  stream = toPull.duplex(stream) //turn into a pull-stream\n  //connect the output of the net stream to the muxrpc stream\n  //and then output of the muxrpc stream to the net stream\n  pull(stream, server.createStream(), stream)\n}).listen(8080)\n//connect a pair of duplex streams together.\n\nconst stream = toPull.duplex(net.connect(8080))\n\nconst onClose = () => {\n  console.log('connected to muxrpc server')\n}\n\npull(stream, client.createStream(onClose), stream)\n\n// Now you can call methods like this.\nclient.hello('world', function (err, value) {\n  if(err) throw err\n  console.log(value)\n  // hello, world!\n})\n\n// Alternatively, you can use the promise syntax.\nclient.hello('world').then((value) => {\n  console.log(value)\n})\n\npull(client.stuff(), pull.drain(console.log))\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n## protocol\n\nAs indicated by the name, `muxrpc` combines both multiplexing and rpc (remote procedure call,\ni.e. request-response). The protocol is described in details in [rpc protocol section of the protocol guide](https://ssbc.github.io/scuttlebutt-protocol-guide/#rpc-protocol)\n\n## Api: createMuxrpc (remoteManifest, localManifest, localApi, id, perms, codec, legacy) => rpc\n\n`remoteManifest` the manifest expected on the remote end of this connection.\n`localManifest` the manifest of the methods we are exposing locally.\n`localApi` the actual methods we are exposing - this is on object with function with call types\nthat match the manifest.\n\n`id` a string identifing the _remote_ identity. `muxrpc` only knows the name of it's friend\nbut not it's own name.\n\n`perms` a permissions object with `{test: function (path, type, args) {} }` function.\n\n`codec` stream encoding. defaults to [packet-stream-codec](https://github.com/ssbc/packet-stream-codec)\n\n`legacy` engage legacy mode.\n\n### rpc\n\nan [EventEmitter](https://devdocs.io/node/events#events_class_eventemitter)\ncontaining proxies for all the methods defined in your manifest, as well as the following:\n\n* `stream`\n* `createStream` method, **only if `legacy` mode**\n* `id` (string, the id of the remote)\n* `_emit` emit an event locally.\n* `closed` a boolean, wether the instance is closed.\n* `close` an async method to close this connection, will end the `rpc.stream`\n\nAnd every method provided in the manifest. If a method in the manifest has the same\nname as a built in, the built in will override the manifest, and you will not be able\nto call that remove method.\n\n## Manifest\n\n`muxrpc` works with async functions, sync functions, and pull-streams.\nBut that javascript is dynamic, we need to tell muxrpc what sort of method\nshould be at what api, that is what the \"mainfest\" is for.\nThe manifest is simply an object mapping a key to one of the strings \"sync\" \"async\" \"source\" \"sink\" or \"duplex\",\nor a nested manifest.\n\n``` js\n{\n  foo: 'async',        //a function with a callback.\n  bar: 'sync',         //a function that returns a value\n                       //(note this is converted to an async function for the client)\n  allTheFoos: 'source' //a source pull-stream (aka, readable)\n  writeFoos: 'sink',   //a sink pull-stream (aka, writable)\n  fooPhone: 'duplex',  //a duplex pull-stream\n\n  //create nested objects like this:\n  bar: {\n    ...\n  }\n}\n\n```\n\n## Permissions\n\nmuxrpc includes a helper module for defining permissions.\nit implements a simple allow/deny list to define permissions for a given connection.\n\n``` js\n\nvar Permissions = require('muxrpc/permissions')\n\nvar manifest = {\n  foo: 'async',\n  bar: 'async',\n  auth: 'async'\n}\n\n//set initial settings\nvar perms = Perms({allow: ['auth']})\n\nvar rpc = muxrpc(null /* no remote manifest */, manifest, serializer)({\n  foo: function (val, cb) {\n    cb(null, {okay: 'foo'})\n  },\n  bar: function (val, cb) {\n    cb(null, {okay: 'bar'})\n  },\n  auth: function (pass) {\n    //implement an auth function that sets the permissions,\n    //using allow or deny lists.\n\n    if(pass === 'whatever')\n      perms({deny: ['bar']}) //allow everything except \"bar\"\n    else if(pass === 's3cr3tz')\n      perms({}) //allow everything!!!\n    else return cb(new Error('ACCESS DENIED'))\n\n    //else we ARE authorized.\n    cb(null, 'ACCESS GRANTED')\n  }\n}, perms) //pass the perms object to the second argument of the constructor.\n\n//Get a stream to connect to the remote. As in the above example!\nvar ss = rpc.createStream()\n\n```\n\n## bootstrapping - automatically loading the remote manifest.\n\nSometimes you don't know the remote manifest yet. If you pass a callback\ninstead of `remoteManifest`, then an async method `manifest` is called on the\nremote, which should return a manifest. This then used as the remote manifest\nand the callback is called.\n\n``` js\nvar manifest = { hello: 'sync', manifest: 'sync' }\n\nvar alice = Muxrpc(null, manifest)({\n  hello: function (message) {\n    if(this._emit) this._emit('hello', message)\n    console.log(`${this.id} received ${message}`)\n    return `${message} to you too`\n  },\n  manifest: function () {\n    return manifest\n  }\n})\n\n\nvar bob = Muxrpc(function (err, manifest) {\n  if (err) throw err\n\n  // Bob now knows Alice's API\n  console.log(manifest) // => { hello: 'sync', manifest: 'sync' }\n\n  bob.hello('aloha', (err, val) => {\n    if (err) throw err\n    console.log(val) // => \"aloha to you too\"\n  })\n})()\n\nvar bobStream = bob.createStream()\n\nalice.id = 'alice'\nbob.id = 'bob'\n\npull(\n  bobStream,\n  alice.createStream(),\n  bobStream\n)\n```\n\n## License\n\nMIT\n\n\n\n"
}