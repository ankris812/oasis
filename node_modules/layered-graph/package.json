{
  "name": "layered-graph",
  "description": "Multigraph data structure that collapses to a simple graph",
  "version": "1.2.0",
  "homepage": "https://github.com/ssbc/layered-graph",
  "repository": {
    "type": "git",
    "url": "git://github.com/ssbc/layered-graph.git"
  },
  "files": [
    "index.js"
  ],
  "dependencies": {
    "dynamic-dijkstra": "^1.0.0",
    "pull-cont": "^0.1.1",
    "pull-notify": "^0.1.1",
    "pull-stream": "^3.6.9"
  },
  "devDependencies": {
    "c8": "^7.12.0",
    "husky": "^4.3.0",
    "prettier": "^2.7.1",
    "pretty-quick": "^3.1.3",
    "tap-arc": "~0.3.5",
    "tape": "^5.5.0"
  },
  "husky": {
    "hooks": {
      "pre-commit": "npm run format-code-staged"
    }
  },
  "author": "Dominic Tarr <dominic.tarr@gmail.com> (http://dominictarr.com)",
  "contributors": [
    "Andre 'Staltz' Medeiros <contact@staltz.com>"
  ],
  "license": "MIT",
  "scripts": {
    "test": "tape test/*.js | tap-arc --bail",
    "coverage": "c8 --reporter=lcov npm test",
    "format-code": "prettier --write \"*.js\" \"test/*.js\"",
    "format-code-staged": "pretty-quick --staged --pattern \"*.js\" --pattern \"test/*.js\""
  },
  "readme": "# layered-graph\n\nCompose a graph out of multiple sublayers, and in particular, expose a\ndynamically updating shortest paths calculation.\n\nLater added layers override earlier layers.\n\n## API: LayeredGraph({start, max}) => layers\n\n`start` is a node id that is the \"root\" of the graph.\nhops are [calculated](https://github.com/dominictarr/dynamic-dijkstra) from this node.\n`max` is a float that is the maximum path length to include in the hops calculation.\n\n### layers.createLayer (name) => add(g) || add(from, to, value)\n\ncreate a layer in this graph. returns an `add` function.\nThe add function should be called with an initial graph,\nand then new edges. Each layer must be initialized.\n`add({})` is a valid initialization, which is adding an empty graph.\n`add(a, b, 1)` would be adding a single edge with weight 1 between a and b.\n\n## layers.getGraph() => g\n\nreturns the current layered graph merged into one layer.\nthe graph is just a two level js object {}, structure `{<id_a>:{<id_b>: <weight>},...}`\n\n### layers.getHops(opts?) => {<id>: <hops>}\n\nreturn a hops map, of each peer id, to their hop length from `start` (passed to constructor)\nIf `opts` is provided, it accepts the following fields:\n`reverse`: return hops _to_ `start` instead of from `start`.\n`start`: calculate hops from/to a different node.\n`max`: set a different max distance.\nIf the `max` is smaller than the default passed to the constructor, the output will be fastest,\nbecause it will just copy the cached value, but skip nodes at a greater distance than `max`.\n\n\n### layers.hopStream() => Source\n\nreturns a pull-stream source, where each message is a hops object (as returned by getHops)\nthe first item will be the current state, and any subsequent objects will be diffs to that object,\ncreated by edges being added or removed in some layer in real time.\n\n### layers.onReady (fn)\n\ncall `fn` back once all layers have been initialized, or immediately if they are already initialized.\n\n### layers.onEdge (fn(from, to, value))\n\ncall `fn` when an edge is added or removed from the graph.\n\n### layers.reset()\n\nClear the state held by this instance, basically going back to how things were\nwhen you called `LayeredGraph({start, max})`.\n\n## License\n\nMIT\n\n\n"
}