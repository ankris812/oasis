{
  "name": "multiblob",
  "description": "A content-addressable store supporting multiple hash algorithms",
  "version": "1.13.8",
  "homepage": "https://github.com/ssbc/multiblob",
  "repository": {
    "type": "git",
    "url": "git://github.com/ssbc/multiblob.git"
  },
  "files": [
    "*.js"
  ],
  "dependencies": {
    "blake2s": "^1.0.1",
    "cont": "^1.0.1",
    "clarify-error": "^1.0.0",
    "mkdirp": "^1.0.4",
    "pull-catch": "^1.0.0",
    "pull-defer": "^0.2.2",
    "pull-file": "^1.0.0",
    "pull-glob": "~1.0.6",
    "pull-live": "^1.0.0",
    "pull-notify": "^0.1.1",
    "pull-paramap": "^1.2.2",
    "pull-stream": "^3.6.2",
    "pull-write-file": "^0.2.1",
    "rimraf": "^3.0.2",
    "stream-to-pull-stream": "^1.7.2"
  },
  "devDependencies": {
    "tape": "^5.2.2",
    "osenv": "^0.1.5"
  },
  "author": "Dominic Tarr <dominic.tarr@gmail.com> (http://dominictarr.com)",
  "license": "MIT",
  "scripts": {
    "prepublish": "npm test",
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "readme": "# multiblob\n\nA content-addressable-store that supports multiple hashing algorithms,\nand pull-streams.\n\n## example\n\n``` js\nvar Blobs = require('multiblob')\n\nvar blobs = Blobs({ dir: '/media/blobCollection' })\n\npull(\n  source, // a buffer stream e.g. from pull-file\n  blobs.add(function (err, hash) {\n    console.log('added source to blobs:', hash)\n  })\n)\n```\n\n## API\n\n### Blobs(config) => blobs\n\nwhere config is an Object with properties:\n- `dir` _String_ - the directory to store blobs in\n- `alg` _String_ (optional) - the algorithm for hashing. Valid options: `'blake2s'`, `'sha256'` (default: `'blake2s'`)\n- `encode` _Function_ (optional) - converts a buffer to a string (default: see `util.js#encode`)\n- `decode` _Function_ (optional) - recovers a string into an object `{ hash: Buffer, alg }` (default: see `util.js#decode`)\n- `isHash` _Function_ (optional) - tests a string to check if it's a valid hash (default: see `util.js#isHash`)\n\n### blobs.add (hash?, cb?) => Sink\n\nCreate a sink stream for writing a blob.\nExpects to receive a buffer stream.\n\nIf `hash` was given, then it will error if the file turned out to be different.\nIf a `cb` is not given and there was an error, this function will throw.\n\n### blobs.get (hash || opts) => Source\n\nTakes the hash of blob already in the store and return a source buffer stream.\nIf the file does not exist this stream will error.\n\nIf the argument is a `hash` string, then return the stream.\nIf the argument is an `opts` object, with the `key: hash` property,\nretrive that blob, but error if the size does not exactly match the\n`size` property, or is over `max` property (in bytes)\n\n### blobs.getSlice(opts) => Source\n\ncreate a source stream that reads a slice of a given blob,\nfrom the `start` property to the `end` property, in bytes.\nError if the file does not exist or if\nthe size of the whole blob does not exactly match the\n`size` property, or is over `max` property (in bytes).\n\n### blobs.has(hash, cb)\n\ncheck if the given hash is in the store.\nIf `hash` is an array of hashes,\n`size` will callback with an array of booleans.\n\n### blobs.size(hash, cb)\n\nget the size of this blob. If `hash` is an array of hashes,\n`size` will callback with an array of sizes.\nIf the hash does not exist in the store, `size` will callback `null`.\n\n\n### blobs.ls() => Source\n\nsource stream that reads the list of hashes available in the store.\n\n### blobs.rm(hash, cb)\n\nremove a hash from the store.\n\n### blobs.isEmptyHash(hash)\n\nCheck if a given hash is actually the empty hash. If something has the empty hash,\nthat is probably a bug. The above methods will act like the empty file is already in the store.\n\n### blobs.meta\n\n???\n\n### blobs.resolve\n\n???\n\n\n## todo\n\nmaybe emit events when blobs are stored?\n\n## License\n\nMIT\n"
}