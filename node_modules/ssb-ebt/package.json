{
  "name": "ssb-ebt",
  "description": "Replicates SSB feeds using Epidemic broadcast trees",
  "version": "9.1.2",
  "author": "'Dominic Tarr' <dominic.tarr@gmail.com> (http://dominictarr.com)",
  "license": "MIT",
  "homepage": "https://github.com/ssbc/ssb-ebt",
  "repository": {
    "type": "git",
    "url": "git://github.com/ssbc/ssb-ebt.git"
  },
  "main": "index.js",
  "files": [
    "*.js",
    "debug/*.js",
    "formats/*.js"
  ],
  "engines": {
    "node": ">=10"
  },
  "dependencies": {
    "base64-url": "^2.2.0",
    "epidemic-broadcast-trees": "^9.0.2",
    "key-value-file-store": "^1.1.1",
    "pull-defer": "^0.2.3",
    "pull-stream": "^3.6.0",
    "push-stream-to-pull-stream": "^1.0.5",
    "ssb-bendy-butt": "^1.0.1",
    "ssb-buttwoo": "^0.3.2",
    "ssb-classic": "^1.1.0",
    "ssb-index-feeds": "~0.10.1",
    "ssb-network-errors": "^1.0.1"
  },
  "devDependencies": {
    "c8": "^7.12.0",
    "cat-names": "^3.0.0",
    "dog-names": "^2.0.0",
    "husky": "^4.3.0",
    "mkdirp": "^1.0.4",
    "prettier": "^2.1.2",
    "pretty-quick": "^3.1.0",
    "promisify-4loc": "^1.0.0",
    "pull-paramap": "^1.2.2",
    "rimraf": "^2.7.1",
    "rng": "^0.2.2",
    "secret-stack": "^6.4.0",
    "ssb-caps": "^1.1.0",
    "ssb-client": "^4.9.0",
    "ssb-db": "^19.2.0",
    "ssb-db2": "^6.2.0",
    "ssb-generate": "^1.0.1",
    "ssb-keys": "^8.5.0",
    "ssb-meta-feeds": "^0.34.0",
    "ssb-ref": "^2.13.0",
    "ssb-validate": "^4.1.4",
    "tap-arc": "^0.3.5",
    "tape": "^5.2.2"
  },
  "husky": {
    "hooks": {
      "pre-commit": "npm run format-code-staged"
    }
  },
  "nyc": {
    "exclude": [
      "!**/node_modules/"
    ],
    "include": [
      "node_modules/epidemic-broadcast-trees/*.js",
      "*.js"
    ]
  },
  "scripts": {
    "test": "tape test/*.js | tap-arc --bail",
    "test-verbose": "TEST_VERBOSE=1 npm test",
    "coverage": "c8 --reporter=lcov npm test",
    "format-code": "prettier --write \"*.js\" \"formats/*.js\" \"test/*.js\"",
    "format-code-staged": "pretty-quick --staged --pattern \"*.js\" --pattern \"formats/*.js\" --pattern \"test/*.js\""
  },
  "readme": "# ssb-ebt\n\n*Replicates SSB feeds using the efficient \"Epidemic broadcast tree\" algorithm.*\n\nThis module is an adapter for the module [epidemic-broadcast-trees](https://github.com/ssbc/epidemic-broadcast-trees)\nto work with [secure-scuttlebutt](http://scuttlebutt.nz/). Supersedes\n[ssb-replicate](https://github.com/ssbc/ssb-replicate).\n\n## Installation\n\n**Prerequisites:**\n\n- Requires **Node.js 10** or higher\n- Requires **ssb-db** or **ssb-db2** version 5.0 or higher\n\n```\nnpm install --save ssb-ebt\n```\n\nAdd this secret-stack plugin like this:\n\n```diff\n const SecretStack = require('secret-stack')\n const caps = require('ssb-caps')\n\n const createSsbServer = SecretStack({ caps })\n     .use(require('ssb-master'))\n     .use(require('ssb-db'))\n+    .use(require('ssb-ebt'))\n     .use(require('ssb-friends'))\n     // ...\n```\n\n## Usage\n\nssb-ebt itself does **NOT** trigger replication automatically after it's\ninstalled, instead, you need to call its API methods yourself (primarily\n`request` or `block`), or use a scheduler module such as\n[ssb-replication-scheduler](https://github.com/ssb-ngi-pointer/ssb-replication-scheduler).\n\n### `ssb.ebt.request(destination, replicating, formatName)` (\"sync\" muxrpc API)\n\nRequest that the SSB feed ID `destination` be replicated. `replication` is a\nboolean, where `true` indicates we want to replicate the destination. If set to\n`false`, replication is stopped. `formatName` is optional and used to specify\nthe specific EBT instance, otherwise the first where isFeed is `true` for\n`destination` is used.\n\nReturns undefined, always.\n\n### `ssb.ebt.block(origin, destination, blocking)` (\"sync\" muxrpc API)\n\nComputes that `origid` does not want to replicate `destination`'s feed. Also\ndisallows other peers (who have this same ssb-ebt installed) to pass on data to\nthem.\n\n`origin` is the SSB feed ID of the peer who created the block, `destination` is\nthe SSB feed ID of the peer being blocked, and `blocking` is a boolean that\nindicates whether to enable the block (`true`) or to unblock (`false`).\n\n`formatName` is optional and used to specify the specific EBT instance,\notherwise the first where isFeed is `true` for `origin` is used.\n\nReturns undefined, always.\n\n### `ssb.ebt.forget(destination)` (\"sync\" muxrpc API)\n\nSame as `ssb.ebt.request(destination, false)`, but also cleans up any persistent\nstate used by the EBT instance for this given `destination` ID.\n\nReturns undefined, always.\n\n### `ssb.ebt.peerStatus(id)` (\"sync\" muxrpc API)\n\nQuery the status of replication for a given SSB feed ID `id`. Returns a JSON\nobject showing the replication state for all peers we are currently\nconnected to.\n\nThe output looks like this:\n\n<details>\n<summary>CLICK HERE</summary>\n\n```js\n{\n  \"id\": \"@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519\",\n  \"seq\": 13293, //the sequence we have locally.\n  \"peers\": {\n    //where each of these peers are up to:\n    \"@TRE4lNNXrtx3KK9Tgks2so2PjCP6w9tRvsy7wyqiyo4=.ed25519\": {\n      \"seq\": 13293, //the sequence this peer has acknowledged, we definitely know they have this number.\n      \"replicating\": {\n        \"tx\": true,\n        \"rx\": true,\n        \"sent\": 13293, //the sequence we have sent to this peer. They _probably_ have this, but not gauranteed.\n        \"requested\": 13293 //the sequence we requested from this peer\n      }\n    },\n    \"@h1fDsZgwBtZndnRDHCFV84TMZYl16m3zhyTTQsE/V94=.ed25519\": {\n      \"seq\": 13293,\n      \"replicating\": {\n        \"tx\": true,\n        \"rx\": false,\n        \"sent\": 13293,\n        \"requested\": 13293\n      }\n    }\n  }\n}\n```\n</details>\n\n### `ssb.ebt.registerFormat(methods)` (\"sync\" muxrpc API)\n\nRegister a new format for replication. Note this does not have to be a\nnew feed format, it could also be indexed replication or sliced\nreplication. See `formats` folder for examples.\n\nBy registering a format you create a new EBT instance used for\nreplicating feeds using that format. This means its own clock. Message\nwill be replicated using the `replicateFormat` API. The `methods`\nargument must implement the following functions. The example below\nshows the implementation for 'classic' ed25519 SSB feeds.\n\n<details>\n<summary>CLICK HERE</summary>\n\n```js\n{\n  name: 'classic',\n  // used in request, block, cleanClock, sbot.post, vectorClock\n  isFeed(feedId) {\n    return ref.isFeed(feedId)\n  },\n  getAtSequence(sbot, pair, cb) {\n    sbot.getAtSequence([pair.id, pair.sequence], (err, msg) => {\n      cb(err, msg ? msg.value : null)\n    })\n  },\n  appendMsg(sbot, msgVal, cb) {\n    sbot.add(msgVal, (err, msg) => {\n      cb(err && err.fatal ? err : null, msg)\n    })\n  },\n\n  // used in ebt:stream to distinguish between messages and notes\n  isMsg(msgVal) {\n    return Number.isInteger(msgVal.sequence) && msgVal.sequence > 0 &&\n      ref.isFeed(msgVal.author) && msgVal.content\n  },\n  // used in ebt:events\n  getMsgAuthor(msgVal) {\n    return msgVal.author\n  },\n  // used in ebt:events\n  getMsgSequence(msgVal) {\n    return msgVal.sequence\n  }\n}\n```\n</details>\n\n### `ssb.ebt.setClockForSlicedReplication(feedId, sequence, formatName)` (\"sync\" muxrpc API)\n\nSets the internal clock of a feed to a specific sequence. Note this\ndoes not start replicating the feed, it only updates the clock. By\ncombining this with `clock` it is possible do to sliced replication\nwith a remote peer where say only the latest 100 messages of a feed is\nreplicated.\n\n### (Internal) `ssb.ebt.replicate(opts)` (\"duplex\" muxrpc API)\n\nCreates a duplex replication stream to the remote peer. When two peers connect,\nthe peer who initiated the call (the client) should call this. You do not need\nto call this method, it is called automatically in ssb-ebt whenever our peer\nconnects to a remote peer. `opts` is an object with one field: `version`.\n\n### (Internal) `ssb.ebt.replicateFormat(opts)` (\"duplex\" muxrpc API)\n\nCreates a duplex replication stream to the remote peer. This behaves\nsimilar to `replicate` except it takes an extra field `format`\nspecifying what is transferred over this EBT stream. Classic feeds are\nstill replicated using `replicate` while this will be used to\nreplicate other feed formats.\n\n### (Internal) `ssb.ebt.clock(opts, cb)` (\"async\" muxrpc API)\n\nGets the current vector clock of a remote peer. `opts` is an object\nwith one field: `format` specifying what format to get the vector\nclock for. Defaults to 'classic'.\n\n## Testing and debugging\n\nThere are several scripts in `./debug` which can be used for testing EBT\nreplication.\n\nUse `./debug/remote.js <address>` to connect to an SSB peer running EBT. Running\nthis won't store anything locally, it will just download everything and drop it\non the floor. This is used to test performance of EBT on a server.\n\nWe normally see values between 2k and 3k messages per second, in other words,\nreplicates 100k messages in under a minute.\n\n## License\n\nMIT\n"
}