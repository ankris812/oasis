"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const secret_stack_decorators_1 = require("secret-stack-decorators");
const broadcast = require('dgram-broadcast');
const Ref = require('ssb-ref');
const Keys = require('ssb-keys');
const Notify = require('pull-notify');
const IP = require('ip');
const nonPrivateIP = require('non-private-ip');
const debug = require('debug')('ssb:lan');
const NORMAL_PORT = require('../port');
const LEGACY_PORT = 8008;
let LAN = class LAN {
    constructor(ssb, config) {
        var _a;
        this.readLegacy = (buf) => {
            if (buf.loopback)
                return;
            const address = buf.toString();
            const peerKey = Ref.getKeyFromAddress(address);
            if (peerKey && peerKey !== this.ssb.id) {
                this.notifyDiscovery({ address, verified: false });
            }
        };
        this.readNormal = (buf) => {
            const ciphertext = buf.slice(0, buf.length - 64);
            const sig = buf.slice(buf.length - 64, buf.length);
            let address;
            try {
                const obj = Keys.secretUnbox(ciphertext, this.caps);
                address = obj.address;
            }
            catch (err) {
                debug('failed to interpret broadcasted message: %s', buf.toString('hex'));
                return;
            }
            const peerKey = Ref.getKeyFromAddress(address);
            if (!peerKey) {
                debug('failed to parse address from broadcasted message: %s', buf.toString('hex'));
                return;
            }
            if (peerKey === this.ssb.id) {
                return;
            }
            const b64sig = sig.toString('base64') + '.sig.ed25519';
            const obj = { address, signature: b64sig };
            const verified = Keys.verifyObj({ public: peerKey }, obj);
            this.notifyDiscovery({ address, verified });
        };
        this.writeBoth = () => {
            this.writeLegacy();
            this.writeNormal();
        };
        this.handleBroadcastError = (err) => {
            debug('dgram-broadcast error: %o', err);
            this.stop();
            this.start();
        };
        this.start = () => {
            var _a, _b, _c, _d, _e, _f;
            const destinations = this.getBroadcastIPs();
            try {
                this.normalBroadcast = broadcast(NORMAL_PORT, true, destinations);
                (_a = this.normalBroadcast) === null || _a === void 0 ? void 0 : _a.on('error', this.handleBroadcastError);
            }
            catch (err) {
                debug('LAN broadcast turned off because: %s', err);
                this.normalBroadcast = void 0;
            }
            try {
                this.legacyBroadcast = this.legacyEnabled
                    ? broadcast(LEGACY_PORT, true, destinations)
                    : void 0;
            }
            catch (err) {
                debug('legacy broadcast turned off because: %s', err);
                this.legacyBroadcast = void 0;
                (_b = this.normalBroadcast) === null || _b === void 0 ? void 0 : _b.on('error', this.handleBroadcastError);
            }
            (_c = this.normalBroadcast) === null || _c === void 0 ? void 0 : _c.on('data', this.readNormal);
            (_d = this.legacyBroadcast) === null || _d === void 0 ? void 0 : _d.on('data', this.readLegacy);
            this.writeBoth();
            this.int = setInterval(this.writeBoth, 2e3);
            (_f = (_e = this.int) === null || _e === void 0 ? void 0 : _e.unref) === null || _f === void 0 ? void 0 : _f.call(_e);
            const that = this;
            this.ssb.close.hook(function (fn, args) {
                that.stop();
                fn.apply(this, args);
            });
        };
        this.stop = () => {
            var _a, _b;
            clearInterval(this.int);
            (_a = this.normalBroadcast) === null || _a === void 0 ? void 0 : _a.close();
            this.normalBroadcast = void 0;
            (_b = this.legacyBroadcast) === null || _b === void 0 ? void 0 : _b.close();
            this.legacyBroadcast = void 0;
        };
        this.discoveredPeers = () => {
            return this.notifyDiscovery.listen();
        };
        this.ssb = ssb;
        this.notifyDiscovery = Notify();
        this.caps = Buffer.from(config.caps.shs, 'base64');
        this.legacyEnabled = ((_a = config.lan) === null || _a === void 0 ? void 0 : _a.legacy) !== false;
    }
    writeLegacy() {
        var _a;
        if (!this.legacyBroadcast)
            return;
        const address = (_a = this.ssb.getAddress('private')) !== null && _a !== void 0 ? _a : this.ssb.getAddress('local');
        if (address)
            this.legacyBroadcast.write(address);
    }
    writeNormal() {
        var _a;
        if (!this.normalBroadcast)
            return;
        const address = (_a = this.ssb.getAddress('private')) !== null && _a !== void 0 ? _a : this.ssb.getAddress('local');
        if (address) {
            const ciphertext = Keys.secretBox({ address }, this.caps);
            const b64sig = Keys.signObj(this.ssb.keys, { address }).signature;
            const sig = Buffer.from(b64sig.replace(/\.sig\.ed25519$/, ''), 'base64');
            const payload = Buffer.concat([ciphertext, sig]);
            this.normalBroadcast.write(payload);
        }
    }
    getBroadcastIPs() {
        if (process.platform === 'ios')
            return ['255.255.255.255'];
        const details = nonPrivateIP(null, IP.isPrivate, true);
        if (!details)
            return ['255.255.255.255'];
        const { broadcastAddress } = IP.subnet(details.address, details.netmask);
        return [broadcastAddress];
    }
};
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('sync')
], LAN.prototype, "start", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('sync')
], LAN.prototype, "stop", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], LAN.prototype, "discoveredPeers", void 0);
LAN = __decorate([
    (0, secret_stack_decorators_1.plugin)('1.1.0')
], LAN);
module.exports = LAN;
