{
  "name": "ssb-bfe",
  "description": "Binary Field Encodings (BFE) for Secure Scuttlebutt (SSB)",
  "version": "3.7.0",
  "homepage": "https://github.com/ssbc/ssb-bfe",
  "repository": {
    "type": "git",
    "url": "git://github.com/ssbc/ssb-bfe.git"
  },
  "main": "index.js",
  "files": [
    "*.js",
    "package.json.license",
    "LICENSES/*"
  ],
  "dependencies": {
    "is-canonical-base64": "^1.1.1",
    "ssb-bfe-spec": "^0.8.0",
    "ssb-ref": "^2.16.0",
    "ssb-uri2": "^2.4.0"
  },
  "devDependencies": {
    "husky": "^4.3.0",
    "nyc": "^15.1.0",
    "prettier": "^2.1.2",
    "pretty-quick": "^3.1.0",
    "tap-arc": "^0.3.5",
    "tape": "^5.2.2"
  },
  "husky": {
    "hooks": {
      "pre-commit": "npm run format-code-staged"
    }
  },
  "author": "Anders Rune Jensen <arj03@protonmail.ch>",
  "contributors": [
    "Andre Staltz <contact@staltz.com>",
    "Mix Irving <mix@protozoa.nz>"
  ],
  "license": "LGPL-3.0",
  "scripts": {
    "test": "tape test/*.js | tap-arc --bail",
    "coverage": "nyc --reporter=lcov npm test",
    "format-code": "prettier --write \"*.js\" \"test/*.js\"",
    "format-code-staged": "pretty-quick --staged --pattern \"*.js\" --pattern \"test/*.js\""
  },
  "readme": "<!--\nSPDX-FileCopyrightText: 2021 Anders Rune Jensen\n\nSPDX-License-Identifier: CC0-1.0\n-->\n\n# SSB BFE\n\nJavascript implementation of the [SSB binary field encodings] spec.\n\nThe spec only has one type of **nil**, but JavaScript has two: `null` and\n`undefined`. ssb-bfe will treat these two values in a way that mirrors what\nJSON.stringify does:\n\n- BFE Encoding an **object** with a `null` field becomes an object with the\n**nil** marker\n  - Similar to `JSON.stringify({a: null}) === '{\"a\": null}'`\n- BFE Encoding an **array** with a `null` element becomes an array with the\n**nil** marker\n  - Similar to `JSON.stringify([null]) === '[null]'`\n- BFE Encoding an **object** with a `undefined` field will **omit** that field\n  - Similar to `JSON.stringify({a: undefined}) === '{}'`\n- BFE Encoding an **array** with an `undefined` element becomes an array with\nthe **nil** marker\n  - Similar to `JSON.stringify([undefined]) === '[null]'`\n\n## API\n\n### `encode(input)`\n\nTakes any JavaScript primitive and returns its encoded counterpart. Is applied\nrecursively in case the input is an object or an array. All inputs are converted\nto [TFD] Buffers, except for objects, arrays, and numbers, which remain the\nsame.\n\n### `decode(input)`\n\nTakes an encoded value (such as the output from `encode`) and returns the\ndecoded counterparts as JavaScript primitives.\n\n### `decodeTypeFormat(input, typeName, formatName)`\n\nTakes an encoded value (such as the output from `encode`), a typeName\nand formatName and returns the decoded counterparts as JavaScript\nprimitives. This is much faster than decode if you know the type.\n\n### `bfeTypes`\n\nReturns the `bfe.json` object that can be used to look up information\nbased on Type and Field. Example:\n\n```\nconst { bfeTypes } = require('ssb-bfe')\nconst classic_key_size = bfeTypes[0][0].data_length\n```\n\n### `bfeNamedTypes`\n\nReturns the `bfe.json` object converted to a map where the keys are\nthe type and format names. Example:\n\n```js\nconst { bfeNamedTypes } = require('ssb-bfe')\nconst FEED = bfeNamedTypes['feed']\nconst CLASSIC_FEED_TF = Buffer.from([FEED.code, FEED.formats['classic'].code])\n```\n\n### `toTF(typeName, formatName)`\n\nSometimes when you're wanting to check what sort of buffer you're handling, you want\nto pivot on the type and format bytes.\n\n```js\nconst CLASSIC_MSG_TF = Buffer.from([1, 0])  // << Did I get the right codes?\n\nif (buf.slice(0, 2).equals(CLASSIC_MSG_TF)) {\n  // ...\n}\n```\n\nbecause remembering those codes is tricky, it's safer to use this convenience method:\n```js\nconst CLASSIC_MSG_TF = bfe.toTF('msg', 'classic')\n```\n\nIf you remembered the type or format name wrong, you'll instantly get an error!\n\n### Check whether a buffer is an encoded type\n\nGiven any input, these functions tell you whether the input is of the specified\ntype (and format, if applicable). Example:\n\n```js\nconst bfe = require('ssb-bfe')\n\nconst x = bfe.encode('@6CAxOI3f+LUOVrbAl0IemqiS7ATpQvr9Mdw9LC4+Uv0=.ed25519')\n\nbfe.isEncodedFeedClassic(x) // true\n```\n\nList of functions:\n\n- `isEncodedFeed(input) => boolean`\n- `isEncodedFeedClassic(input) => boolean`\n- `isEncodedFeedGabbygroveV1(input) => boolean`\n- `isEncodedFeedBamboo(input) => boolean`\n- `isEncodedFeedBendybuttV1(input) => boolean`\n- `isEncodedFeedButtwooV1(input) => boolean`\n- `isEncodedMessage(input) => boolean`\n- `isEncodedMessageClassic(input) => boolean`\n- `isEncodedMessageGabbygroveV1(input) => boolean`\n- `isEncodedMessageCloaked(input) => boolean`\n- `isEncodedMessageBamboo(input) => boolean`\n- `isEncodedMessageBendybuttV1(input) => boolean`\n- `isEncodedMessageButtwooV1(input) => boolean`\n- `isEncodedBlob(input) => boolean`\n- `isEncodedBlobClassic(input) => boolean`\n- `isEncodedEncryptionKey(input) => boolean`\n- `isEncodedEncryptionKeyBox2DmDh(input) => boolean`\n- `isEncodedEncryptionKeyBox2PoboxDh(input) => boolean`\n- `isEncodedSignature(input) => boolean`\n- `isEncodedSignatureMsgEd25519(input) => boolean`\n- `isEncodedEncrypted(input) => boolean`\n- `isEncodedEncryptedBox1(input) => boolean`\n- `isEncodedEncryptedBox2(input) => boolean`\n- `isEncodedGeneric(input) => boolean`\n- `isEncodedGenericStringUTF8(input) => boolean`\n- `isEncodedGenericBoolean(input) => boolean`\n- `isEncodedGenericNil(input) => boolean`\n- `isEncodedGenericAnyBytes(input) => boolean`\n- `isEncodedIdentity(input) => boolean`\n- `isEncodedIdentityPoBox(input) => boolean`\n\n\n[ssb binary field encodings]: https://github.com/ssb-ngi-pointer/ssb-binary-field-encodings-spec\n[TFD]: https://github.com/ssbc/envelope-spec/blob/master/encoding/tfk.md\n"
}