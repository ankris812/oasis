{
  "name": "push-stream",
  "description": "simple push-based streams",
  "version": "11.2.0",
  "homepage": "https://github.com/push-stream/push-stream",
  "repository": {
    "type": "git",
    "url": "git://github.com/push-stream/push-stream.git"
  },
  "files": [
    "sinks",
    "sources",
    "throughs",
    "*.js"
  ],
  "dependencies": {},
  "devDependencies": {
    "c8": "^7.12.0",
    "micro-bmark": "^0.2.0",
    "prettier": "^2.7.1",
    "pull-stream": "^3.6.14",
    "tap-arc": "~0.3.5",
    "tape": "^5.5.3"
  },
  "author": "'Dominic Tarr' <dominic.tarr@gmail.com> (dominictarr.com)",
  "contributors": [
    "Andre 'Staltz' Medeiros <contact@staltz.com>"
  ],
  "license": "MIT",
  "scripts": {
    "format-code": "prettier --write \"*.js\" \"benchmarks/*.js\" \"sinks/*.js\" \"sources/*.js\" \"test/*.js\" \"throughs/*.js\"",
    "benchmark": "node ./benchmarks/cpu.js && node --expose-gc ./benchmarks/mem-pull.js && node --expose-gc ./benchmarks/mem-push.js",
    "test": "tape test/*.js | tap-arc --bail",
    "coverage": "c8 --reporter=lcov npm run test"
  },
  "readme": "# push-stream\n\nThis is a reimagining of what a push-style stream could be.\n\n`push-stream` harkens back to the original [node.js classic streams](http://dominictarr.com/post/145135293917/history-of-streams)\nbut without several of the unrealized-at-the-time blunders of classic streams.\n\n* don't use event emitters. emitters magnify the needed number of objects, and it's not necessary to assign event listeners to properly working streams.\n  when that is needed, pipe to a stream that supports inspection or wrap the stream to be monitored.\n* don't support multiple destinations - most streams are piped only to one destination. to use a plumbing metaphore, when you want to connect split one pipe into two, you use a special T or Y shaped connector.\n* have a `paused` property instead of `write()` returning paused, this means you can know whether\n  your destination is paused _before_ you call write.\n* call a `resume` method on the source stream (that stays the same) instead of assigning and reassigned \"drain\" listeners.\n  the only property that changes while streaming is the `paused` boolean. No closures are necessary (which are related to memory leaks and not optimized by js engines)\n  possibly a stream has a buffer (array) but otherwise no memory should be allocated on most simple streams.\n\npush-streams also incorporates the lessons learned over several\nyears working with [pull-streams](https://github.com/pull-stream/pull-stream).\nFor additional context learn about the [history of node streams](http://dominictarr.com/post/145135293917/history-of-streams)\nand the [simplicity of pull-streams](http://dominictarr.com/post/149248845122/pull-streams-pull-streams-are-a-very-simple)\n\n## motivation\n\nI wrote this because I wanted muxrpc to have back pressure.\nmuxrpc@<=6 wrapped a simple streaming model called \"packet-stream\",\nwhich internally used a stream model called \"weird streams\" (yes,\nthat is a sign I didn't really know what to do there) but it was\nmuch easier to write a multiplexer with a push model (I tried\nwriting a pull based muxer and got stuck in many deadlocks)\n\n[push-mux](https://github.com/push-stream/push-mux) was relatively\nstraightforward once I figured out what the push-stream api looked like.\n\nI'm not planning on rewriting everything that uses pull-streams\nto use this! So I also made [push-stream-to-pull-stream](https://github.com/push-stream/push-stream-to-pull-stream)\n\n\n## interfaces\n\n### Sink (aka writable)\n\n### sink.write(data)\n\nwrite one chunk of data to a stream.\nthis **must not** be called if `sink.paused == true`.\n\n### sink.end(err)\n\nend the stream. if `err` is an Error, that means the stream has\naborted with a fatal error, throw away any buffered data and\nstop immediately.\n\nwhen sink.end is called with an error, it does not need to respect\n`pause` because the stream is discarded at that point.\n\nif it's an ordinary end, then the caller should wait\nuntil the stream is unpaused.\n\n### sink.paused\n\nboolean of the current pause state. when writing to a stream,\ncheck the value of `paused` both _before_ and _after_.\nIf the sink is paused, a transform stream will usually\nalso pause.\n\n### Source (aka readable)\n\n#### source.pipe(sink)\n\nattach this stream to `sink` stream\n(or pipeline starting with a sink) if `source` has `pipe` should\ncall `source.resume()` and while sink is not paused it should\nwrite any available data to it.\n\n#### source.resume()\n\nIf a sink sets `paused = true` then the source should stop writing.\nwhen the sink decides it is realy for data again, it must call\nthe source - via the `resume` method. If there is data available\nthe source should write it to the sink. If the source is a transform\nstream (i.e. has it's own source) then it would call\nresume on that source (pass the resume signal along)\n\n## combinations\n\nThere are 2 basic types of streams, source and sink.\nand these two types can be combined in two ways: transform and duplex.\n\n## source\n\na stream that pipes data to a sink.\n\n## sink\n\na stream that receives data from a source\n\n## transform : sink -> source\n\nA stream that receive data from a source, possibly transforms it\nin some way, and then pipes it to another sink. When the transform's\nsink pauses, the transform should also pause.\n\n## duplex : {source + sink}\n\nA stream that is both a source and a sink, but source/sink are\nnot internally connected like they are in a transform stream.\nDuplex streams are used for communication - two processes are\nconnected via a \"wire\" (serialized bytes transmitted, then parsed\nby the receiver). On a duplex stream, the pause state of the input\nis not connected to the pause state of the output, instead it's\nprobably connected to the internal state of the system the duplex\nstream connects to.\n\nThis is a subtle distinction and probably only advanced use cases\nrequire writing duplex streams (you are doing protocol design if you are writing a duplex stream)\n\n## how data flows through a push stream pipe\n\nIn node.js streams, there is a complicated \"pipe\" method\nthat defines how data flows between the streams. In `push-stream`\nthe `pipe` method just connects the streams together, and\ninstead of emitting events, the streams just call `write` and `end`\non the next stream in the pipeline directly.\n\n## simplest push-streams examples\n\n### Source: read an array into a stream\n\nA push-stream source is a simple object with a\n`pipe` `resume` and `abort` method.\n\nA push-stream pipeline\nis just a doubly-linked list. the `sink` property is a reference\nto the next stream in the pipeline, and `source` is a reference\nto the previous stream. The words `Source` and `Sink` are also\nused to refer to the first and last streams in a pipeline.\nThe `pipe` method just sets up these references, and the `resume`\nmethod starts the data flowing. The data should flow until\nthe sink stream is paused, as indicated by it setting the\n`paused` property to true.\n\n``` js\n//a stream that reads an array\nfunction Values (ary) {\n  var i = 0\n  return {\n    resume: function () {\n      if(!this.sink || this.ended) return\n\n      while(!this.sink.paused && i < ary.length)\n        this.sink.write(ary[i++])\n\n      //note: end does not check pause state.\n      //pause does not block end.\n      if(i === ary.length) this.sink.end()\n    },\n    //pipe() can be as simple as connecting streams together!\n    pipe: function (sink) {\n      this.sink = sink\n      sink.source = this\n      this.resume()\n      return sink\n    },\n    //abort ends the stream immediately.\n    abort: function (err) {\n      this.ended = err\n      //if the stream has ended, abort immediately.\n      if(!this.sink.ended) this.sink.end(err)\n    }\n  }\n\n}\n```\n\n(See a [pull-stream version](https://github.com/dominictarr/pull-stream-examples/blob/master/pull.js#L1-L21).)\n\n### sink: write a stream to console\n\nA sink stream has `write` and `end` methods and a `paused` property.\nIn [pull-stream](https://github.com/pull-stream/pull-stream)s, the sink is responsible for calling the source\nbut in push-streams it's the reverse - so the push-stream sink\ndoesn't need very much at all.\n\n``` js\nreturn Log (name) {\n  return {\n    paused: false,\n    write: function (data) { \n      console.log(data)\n      //if you set paused=true here, the source should stop writing.\n    },\n    end: function (err) {\n      this.ended = err || true\n    }\n  }\n}\n```\n\n(See a [pull-stream version](https://github.com/dominictarr/pull-stream-examples/blob/master/pull.js#L23-L44).)\n\n### through: map a stream by a function\n\nthe through stream is more complicated in push-streams because\nit needs to have the apis of both source and sink.\nThis is a very simple example through stream that does not\nhave it's own internal buffer. It just writes to the sink\nimmediately. This may mean writing when the sink is paused in\nsome situations, if this is a problem drop in a buffering stream\n\nNote: push-stream throughs must start out with `paused=true`,\nsinks start out `paused=false`. If a through stream is piped to a\ndestination that is unpaused, it should resume, which will propagate\nthe resume signal back up the pipeline and data will start flowing.\n\n``` js\nfunction Map(fn) {\n  return {\n    paused: true,\n    write: function (data) {\n      this.sink.write(fn(data))\n      this.paused = this.sink.paused\n    },\n    end: function (err) {\n      this.ended = err || true\n      this.sink.end(err)\n    },\n    resume: function () {\n      this.source.resume()\n    },\n    pipe: function (sink) {\n      this.sink = sink\n      sink.source = this\n      this.paused = this.sink.paused\n      if(!this.sink.paused)\n        this.resume()\n      return sink\n    },\n    abort: function (err) {\n      this.source.abort(err)\n    }\n  }\n}\n```\n\n\n## acknowledgements\n\nThanks to [@ahdinosaur](https://github.com/ahdinosaur)\nfor giving me the push-stream npm repo!\nHis push-stream module (essentially a simple observable)\nis still available at push-stream@2\n\n## License\n\nMIT\n\n\n"
}