{
  "name": "ssb-private-group-keys",
  "description": "A collection of basic box2 functions for SSB",
  "version": "1.1.1",
  "homepage": "https://github.com/ssbc/ssb-private-group-keys",
  "repository": {
    "type": "git",
    "url": "git://github.com/ssbc/ssb-private-group-keys.git"
  },
  "dependencies": {
    "envelope-js": "^1.3.2",
    "futoin-hkdf": "^1.5.1",
    "private-group-spec": "^1.1.3",
    "sodium-universal": "^3.1.0",
    "ssb-bfe": "^3.5.0"
  },
  "devDependencies": {
    "is-canonical-base64": "^1.1.1",
    "ssb-keys": "^8.4.1",
    "ssb-ref": "^2.16.0",
    "ssb-uri2": "^2.0.2",
    "standard": "^17.0.0",
    "tap-arc": "^0.3.5",
    "tape": "^4.15.1"
  },
  "author": "mixmix",
  "license": "LGPL-3.0-only",
  "scripts": {
    "test": "npm run test:js && npm run test:only && npm run lint",
    "test:js": "tape 'test/**/*.test.js' | tap-arc",
    "test:only": "if grep -r --exclude-dir=node_modules --exclude-dir=.git --color 'test\\.only' ; then exit 1; fi",
    "lint": "standard --fix",
    "generate": "rm -rf test/generate/*/vectors && node test/generate/index.js"
  },
  "readme": "# ssb-private-group-keys\n\nBasic helper functions implementing the [private-group] spec.\n\nCurrently supports classic & bendy butt feed types.\n\n## API\n\n### `directMessageKey(x_dh_secret, x_dh_public, x_feed_id, y_dh_public, y_feed_id) => { key, scheme }`\n\nCreate a shared key for communication between your feed and _another_ feed.\n\nIf you are _encrypting_ a DM, `x` is your feed, and `y` is the person you are DM'ing.\nIf you are _decrypting_ a DM, `x` is your feed, and `y` is the message author's.\n  - NOTE: this is only for the case that the author is someone else, if you're the author, use your `own_key`\n\n- `x_dh_secret`, `x_dh_public` are feed x's diffie-hellman keys\n- `x_feed_id` is the feedId of `x`\n- `y_dh_public` is feed y's diffie-hellman public key\n- `y_feed_id` is the feedId of `y`\n\nAll inputs are [BFE] style buffers.\n\nThe output is a `key` (buffer) and associated `scheme` (string) which can be passed into an envelope `key_slot`\n\n\n#### `directMessageKey.easy(myKeys) => makeKey(feedId) => { key, scheme }`\n\nConvenience function which wraps `directMessageKey`\n\n---\n\n### `poBoxKey(x_dh_secret, x_dh_public, x_id, y_dh_public, y_id) => { key, scheme }`\n\nIf you are _encrypting_ to a P.O. Box, then `x` is your feed, and `y` is the P.O. Box.\nIf you are _decrypting_ a message sent to a P.O. Box, then `x` is the P.O. Box, and `y` is the message author's feed.\n\n- `x_dh_secret`, `x_dh_public` are x's diffie-hellman keys\n- `x_id` is the BFE id of `x`\n- `y_dh_public` is y's diffie-hellman public key\n- `y_id` is the BFE id of `y`\n\nAll inputs are [BFE] style buffers.\n\nThe output is a `key` (buffer) and associated `scheme` (string) which can be passed into an envelope `key_slot`\n\n\n#### `poBoxKey.easy(myKeys) => makeKey(poboxId) => { key, scheme }`\n\nConvenience function which wraps `poBoxKey`\n\n\n---\n\n### `new SecretKey(length?) => secretKey`\n\nCreate a secret key that can be used for the group or message key.\n\nmethods:\n- `secretKey.toBuffer() => buffer` return raw buffer with the key data in it\n- `secretKey.toString() => string` returns a `base64` encoded string of the key\n\n### `new SecretKey(buffer) => secretKey`\n\nAn alternative way to use the constructor, in case you already have the group\nkey bytes as a buffer, is to pass the buffer as the argument. This simply\n\"embodies\" the group key as a `SecretKey` instance, it doesn't generate anything\nnew.\n\n---\n\n### `new DiffieHellmanKeys(keys?, opts?) => dhKeys`\n\n_alias: `DHKeys`_\n\nwhere:\n- `keys` *Object* (optional)\n    - is a pair of keys `{ public, secret? }`, each a Buffer or base64 encoded String\n        - `public` is required, `secret` is optional\n    - if not provided, you are expected to call `dhKeys.generate()` to generate a keypair\n- `opts` *Object* (optional)\n    - `opts.fromEd25519` *Boolean* sets whether the keys are ed25519 signing keys you would like converted to curve25519 encryption keys.\n        - default: `false`\n    - `opts.format` *Integer* sets whether the BFE \"format\" of the encryption key type\n        - if `opts.fromEd25519 = true` was used, it's assumed these are dm keys (`format = 0`)\n        - else format is not set, which is fine as long as you don't call `dhKeys.toBFE()`\n- `dhKeys` *DiffieHellmanKeys instance* with methods:\n    - `dhKeys.generate() => dhKeys` - generates public and private dh keys\n    - `dhKeys.toBuffer() => { public: Buffer, secret: Buffer }` - returns the raw keys as Buffers\n    - `dhKeys.toBFE() => { public: BFE, secret: BFE }` - return [BFE] encodings of the keys (as Buffers)\n\n### `DiffieHellmanKeys.scalarMult(A, B) => result`\n\nA class method for creating shared encryption keys.\n- `A` a DHKeys instance, must include `secret` key\n- `B` a DHKeys instance\n- `result` *Buffer* the result of the scalarMult\n    - only useful in advanced cases to conserve memory\n\nNOTE:\n- method also takes appropriately shaped objects, see source code.\n- there's an advanced signature if you need to conserve memory `(A, B, result) => result`\n\n\n---\n\n## History\n\nThis library was originally extracted from [ssb-tribes].\n\n[private-group]: https://github.com/ssbc/private-group-spec\n[ssb-tribes]: https://github.com/mixmix/ssb-tribes\n[BFE]: https://github.com/ssb-ngi-pointer/ssb-binary-field-encodings-spec\n\n"
}