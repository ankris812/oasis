"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnScheduler = void 0;
const z = require("ziii");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const ConnQuery = require("ssb-conn-query");
const { hasNoAttempts, hasOnlyFailedAttempts } = ConnQuery;
const pull = require('pull-stream');
const Pausable = require('pull-pause');
const ip = require('ip');
const onWakeup = require('on-wakeup');
const onNetwork = require('on-change-network-strict');
const hasNetworkRightNow = require('has-network2');
const Ref = require('ssb-ref');
const debug = require('debug')('ssb:conn:scheduler');
const SECONDS = 1e3;
const MINUTES = 60e3;
const HOUR = 60 * 60e3;
const RANDOM_MULTIPLIER = 0.8 + Math.random() * 0.4;
let lastCheck = 0;
let lastValue = null;
function hasNetwork() {
    if (lastCheck + 1e3 < Date.now()) {
        lastCheck = Date.now();
        lastValue = hasNetworkRightNow();
    }
    return lastValue;
}
function take(n) {
    return (arr) => arr.slice(0, Math.max(n, 0));
}
function filter(condition) {
    return (arr) => arr.filter(condition);
}
function detectType(peer) {
    const [addr, data] = peer;
    if (data.type === 'bt')
        return 'bt';
    if (data.type === 'lan')
        return 'lan';
    if (data.type === 'internet')
        return 'internet';
    if (data.type === 'dht')
        return 'dht';
    if (data.type === 'pub')
        return 'pub';
    if (data.type === 'room')
        return 'room';
    if (data.type === 'room-endpoint' || data.type === 'room-attendant') {
        if (data.alias)
            return 'room-attendant-alias';
        else
            return 'room-attendant';
    }
    if (data.source === 'local')
        return 'lan';
    if (data.source === 'pub')
        return 'pub';
    if (data.source === 'internet')
        return 'internet';
    if (data.source === 'dht')
        return 'dht';
    if (data.inferredType === 'bt')
        return 'bt';
    if (data.inferredType === 'lan')
        return 'lan';
    if (data.inferredType === 'dht')
        return 'dht';
    if (data.inferredType === 'internet')
        return 'internet';
    if (addr.startsWith('bt:'))
        return 'bt';
    if (addr.startsWith('dht:'))
        return 'dht';
    return '?';
}
const isNotLocalhost = (p) => !ip.isLoopback(p[1].host) && p[1].host !== 'localhost';
function isNotRoom(peer) {
    return peer[1].type !== 'room';
}
function isRoom(peer) {
    return peer[1].type === 'room';
}
function isDefunct(peer) {
    return peer[1].defunct === true;
}
function filterOldExcess(excess) {
    return (peers) => {
        const WAIT_TIME = 2 * MINUTES * RANDOM_MULTIPLIER;
        return peers.filter((p) => Date.now() > p[1].hubUpdated + WAIT_TIME / excess);
    };
}
function sortByOldestConnection(peers) {
    return peers.sort((a, b) => {
        return a[1].hubUpdated - b[1].hubUpdated;
    });
}
function calculateCooldown(fullPercent, hops) {
    return (peers) => {
        return peers.map((peer) => {
            const [, data] = peer;
            const peerType = detectType(peer);
            const normalizedFullPercent = Math.max(0.1, fullPercent);
            const hop = hops[data.key];
            const hopsCooldown = peerType === 'room'
                ? 1 * SECONDS
                : hop === null || hop === void 0 || hop < 0
                    ? Infinity
                    : hop * SECONDS;
            const retryCooldown = 4 * SECONDS + Math.min(64, data.failure || 0) ** 3 * 10 * SECONDS;
            let cooldown = (hopsCooldown + retryCooldown) * normalizedFullPercent;
            if (hasNoAttempts(peer))
                cooldown *= 0.5;
            if (Math.random() < 0.3)
                cooldown *= 0.5;
            if (peerType === 'lan')
                cooldown *= 0.7;
            if (peerType === 'room-attendant')
                cooldown *= 0.8;
            if (hasOnlyFailedAttempts(peer))
                cooldown *= 3;
            data.cooldown = cooldown;
            return peer;
        });
    };
}
function cooledDownEnough(peer) {
    var _a, _b;
    const [, data] = peer;
    const lastAttempt = (_b = (_a = data.stateChange) !== null && _a !== void 0 ? _a : data.hubUpdated) !== null && _b !== void 0 ? _b : 0;
    if (data.cooldown === undefined)
        return true;
    return Date.now() > lastAttempt + data.cooldown;
}
function sortByCooldownAscending(peers) {
    return peers.sort((a, b) => {
        const [, aData] = a;
        const [, bData] = b;
        if (aData.cooldown === undefined)
            return 1;
        if (bData.cooldown === undefined)
            return -1;
        return aData.cooldown - bData.cooldown;
    });
}
let ConnScheduler = class ConnScheduler {
    constructor(ssb, config) {
        this.isBlocked = (peer) => {
            const [, data] = peer;
            if (!(data === null || data === void 0 ? void 0 : data.key))
                return false;
            return this.hops[data.key] === -1;
        };
        this.isNotBlocked = (peer) => {
            return !this.isBlocked(peer);
        };
        this.isNotConnected = (address) => {
            return !this.ssb.conn.hub().getState(address);
        };
        this.start = () => {
            var _a, _b, _c, _d;
            if (!this.closed)
                return;
            this.closed = false;
            this.cleanUpDB();
            this.ssbDB2Subscription = (_b = (_a = this.ssb.db) === null || _a === void 0 ? void 0 : _a.onMsgAdded) === null || _b === void 0 ? void 0 : _b.call(_a, ({ kvt }) => {
                if (kvt.value.author !== this.ssb.id) {
                    this.lastMessageAt = Date.now();
                }
            });
            this.loadSocialGraph();
            this.setupBluetoothDiscovery();
            this.setupLanDiscovery();
            this.setupRoomAttendantDiscovery();
            this.setupPubDiscovery();
            this.intervalForUpdate = setInterval(() => this.updateSoon(), 2e3);
            (_d = (_c = this.intervalForUpdate) === null || _c === void 0 ? void 0 : _c.unref) === null || _d === void 0 ? void 0 : _d.call(_c);
            onWakeup(() => {
                if (!this.closed)
                    this.ssb.conn.hub().reset();
            });
            onNetwork(() => {
                if (!this.closed)
                    this.ssb.conn.hub().reset();
            });
            pull(this.ssb.conn.hub().listen(), pull.filter((ev) => ev.type === 'disconnected'), pull.drain(() => this.updateSoon(200)));
            this.updateNow();
        };
        this.stop = () => {
            var _a, _b, _c;
            (_a = this.pubDiscoveryPausable) === null || _a === void 0 ? void 0 : _a.pause();
            (_b = this.ssb.lan) === null || _b === void 0 ? void 0 : _b.stop();
            (_c = this.ssbDB2Subscription) === null || _c === void 0 ? void 0 : _c.call(this);
            if (this.intervalForUpdate) {
                clearInterval(this.intervalForUpdate);
                this.intervalForUpdate = void 0;
            }
            this.ssb.conn.hub().reset();
            this.closed = true;
        };
        this.ssb = ssb;
        this.config = config;
        this.closed = true;
        this.lastMessageAt = 0;
        this.lastRotationAt = 0;
        this.hasScheduledAnUpdate = false;
        this.loadedHops = false;
        this.hops = {};
    }
    loadSocialGraph() {
        var _a, _b;
        if (!((_a = this.ssb.friends) === null || _a === void 0 ? void 0 : _a.hopStream)) {
            debug('Warning: ssb-friends@5 is missing, scheduling is degraded');
            this.loadedHops = true;
            return;
        }
        pull((_b = this.ssb.friends) === null || _b === void 0 ? void 0 : _b.hopStream({ live: true, old: true }), pull.drain((h) => {
            this.hops = { ...this.hops, ...h };
            this.loadedHops = true;
        }));
    }
    isCurrentlyDownloading() {
        return this.lastMessageAt && this.lastMessageAt > Date.now() - 500;
    }
    maxWaitToConnect(peer) {
        const type = detectType(peer);
        switch (type) {
            case 'lan':
                return 30e3;
            case 'room-attendant-alias':
                return 30e3;
            case 'bt':
                return 60e3;
            case 'dht':
                return 300e3;
            default:
                return 10e3;
        }
    }
    maintainConnections(quota, isDesiredPeer, pool, isPeerRotatable, rotationPeriod) {
        const query = this.ssb.conn.query();
        const peersUp = query.peersConnected().filter(isDesiredPeer);
        const peersDown = query
            .peersConnectable(pool)
            .filter(isDesiredPeer)
            .filter(this.isNotBlocked)
            .filter(isNotLocalhost)
            .filter(([, data]) => data.autoconnect !== false);
        const excess = peersUp.length > quota * 2 ? peersUp.length - quota : 0;
        const freeSlots = Math.max(quota - peersUp.length, 0);
        const fullPercent = 1 - freeSlots / quota;
        z(peersUp)
            .z(filterOldExcess(excess))
            .z(sortByOldestConnection)
            .z(take(excess))
            .forEach(([addr]) => this.ssb.conn.disconnect(addr));
        const ROTATION_PERIOD = (rotationPeriod * RANDOM_MULTIPLIER) / Math.sqrt(peersDown.length);
        if (freeSlots === 0 &&
            peersDown.length > 0 &&
            this.lastRotationAt + ROTATION_PERIOD < Date.now()) {
            z(peersUp)
                .z(filter(isPeerRotatable !== null && isPeerRotatable !== void 0 ? isPeerRotatable : (() => true)))
                .z(filter(([, data]) => {
                var _a, _b;
                const lastAttempt = (_b = (_a = data.stateChange) !== null && _a !== void 0 ? _a : data.hubUpdated) !== null && _b !== void 0 ? _b : 0;
                return lastAttempt + ROTATION_PERIOD < Date.now();
            }))
                .z(sortByOldestConnection)
                .z(take(1))
                .forEach(([addr]) => {
                this.lastRotationAt = Date.now();
                this.ssb.conn.disconnect(addr);
            });
        }
        z(peersDown)
            .z(calculateCooldown(fullPercent, this.hops))
            .z(filter(cooledDownEnough))
            .z(sortByCooldownAscending)
            .z(take(freeSlots))
            .forEach(([addr, data]) => this.ssb.conn.connect(addr, data));
    }
    updateStagingNow() {
        this.ssb.conn
            .query()
            .peersConnectable('db')
            .filter(this.isNotBlocked)
            .filter(([, data]) => data.autoconnect === false)
            .forEach(([addr, data]) => this.ssb.conn.stage(addr, data));
        this.ssb.conn
            .query()
            .peersConnectable('staging')
            .filter(this.isBlocked)
            .forEach(([addr]) => this.ssb.conn.unstage(addr));
        this.ssb.conn
            .query()
            .peersConnectable('staging')
            .filter(([, data]) => data.type === 'lan')
            .filter(([, data]) => data.stagingUpdated + 10e3 < Date.now())
            .forEach(([addr]) => this.ssb.conn.unstage(addr));
        this.ssb.conn
            .query()
            .peersConnectable('staging')
            .filter(([, data]) => data.type === 'bt')
            .filter(([, data]) => data.stagingUpdated + 30e3 < Date.now())
            .forEach(([addr]) => this.ssb.conn.unstage(addr));
    }
    updateHubNow() {
        this.maintainConnections(5, isRoom, 'db', (p) => p[1].onlineCount === 0, 2 * MINUTES);
        this.maintainConnections(4, isNotRoom, 'dbAndStaging', null, 2 * HOUR);
        this.ssb.conn
            .query()
            .peersInConnection()
            .filter(this.isBlocked)
            .forEach(([addr]) => this.ssb.conn.disconnect(addr));
        this.ssb.conn
            .query()
            .peersInConnection()
            .filter((p) => this.ssb.conn.hub().getState(p[0]) === 'connecting')
            .filter((p) => p[1].stateChange + this.maxWaitToConnect(p) < Date.now())
            .forEach(([addr]) => this.ssb.conn.disconnect(addr));
    }
    updateNow() {
        if (this.closed)
            return;
        if (this.isCurrentlyDownloading())
            return;
        if (!this.loadedHops)
            return;
        if (!hasNetwork())
            return;
        this.updateStagingNow();
        this.updateHubNow();
    }
    updateSoon(period = 1000) {
        if (this.closed)
            return;
        if (this.hasScheduledAnUpdate)
            return;
        const fuzzyPeriod = period * 0.5 + period * Math.random();
        this.hasScheduledAnUpdate = true;
        const timer = setTimeout(() => {
            this.updateNow();
            this.hasScheduledAnUpdate = false;
        }, fuzzyPeriod);
        if (timer.unref)
            timer.unref();
    }
    removeDefunct(addr) {
        this.ssb.conn.db().update(addr, { defunct: void 0, autoconnect: void 0 });
    }
    setupBluetoothDiscovery() {
        var _a;
        if (!((_a = this.ssb.bluetooth) === null || _a === void 0 ? void 0 : _a.nearbyScuttlebuttDevices)) {
            debug('Warning: ssb-bluetooth is missing, scheduling is degraded');
            return;
        }
        pull(this.ssb.bluetooth.nearbyScuttlebuttDevices(1000), pull.drain(({ discovered }) => {
            if (this.closed)
                return;
            for (const btPeer of discovered) {
                const addr = `bt:${btPeer.remoteAddress.split(':').join('')}` +
                    '~' +
                    `shs:${btPeer.id.replace(/^\@/, '').replace(/\.ed25519$/, '')}`;
                const data = {
                    type: 'bt',
                    note: btPeer.displayName,
                    key: btPeer.id,
                };
                if (this.isNotBlocked([addr, data]) && this.isNotConnected(addr)) {
                    this.ssb.conn.stage(addr, data);
                    this.updateSoon(100);
                }
            }
        }));
    }
    setupLanDiscovery() {
        var _a, _b;
        if (!((_a = this.ssb.lan) === null || _a === void 0 ? void 0 : _a.start) || !((_b = this.ssb.lan) === null || _b === void 0 ? void 0 : _b.discoveredPeers)) {
            debug('Warning: ssb-lan is missing, scheduling is degraded');
            return;
        }
        pull(this.ssb.lan.discoveredPeers(), pull.drain(({ address, verified }) => {
            const key = Ref.getKeyFromAddress(address);
            if (!key)
                return;
            const data = {
                type: 'lan',
                key,
                verified,
            };
            if (this.isNotBlocked([address, data]) &&
                this.isNotConnected(address)) {
                this.ssb.conn.stage(address, data);
                this.updateSoon(100);
            }
        }));
        this.ssb.lan.start();
    }
    setupRoomAttendantDiscovery() {
        var _a;
        const timer = setTimeout(() => {
            var _a;
            if (!((_a = this.ssb.roomClient) === null || _a === void 0 ? void 0 : _a.discoveredAttendants)) {
                debug('Warning: ssb-room-client@2 is missing, scheduling is degraded');
                return;
            }
            pull(this.ssb.roomClient.discoveredAttendants(), pull.drain((attendant) => {
                const addr = attendant.address;
                const data = {
                    type: 'room-attendant',
                    key: attendant.key,
                    room: attendant.room,
                    roomName: attendant.roomName,
                };
                if (this.isNotBlocked([addr, data]) && this.isNotConnected(addr)) {
                    this.ssb.conn.stage(addr, data);
                    this.updateSoon(100);
                }
            }));
        }, 100);
        (_a = timer === null || timer === void 0 ? void 0 : timer.unref) === null || _a === void 0 ? void 0 : _a.call(timer);
    }
    setupPubDiscovery() {
        var _a, _b, _c;
        if (((_a = this.config.conn) === null || _a === void 0 ? void 0 : _a.populatePubs) === false)
            return;
        if (!((_b = this.ssb.db) === null || _b === void 0 ? void 0 : _b.operators)) {
            debug('Warning: ssb-db2 is missing, scheduling is degraded');
            return;
        }
        const timer = setTimeout(() => {
            var _a, _b;
            if (this.closed)
                return;
            if (!((_a = this.ssb.db) === null || _a === void 0 ? void 0 : _a.operators))
                return;
            const MAX_STAGED_PUBS = 3;
            const { where, type, live, toPullStream } = this.ssb.db.operators;
            this.pubDiscoveryPausable = (_b = this.pubDiscoveryPausable) !== null && _b !== void 0 ? _b : Pausable();
            pull(this.ssb.db.query(where(type('pub')), live({ old: true }), toPullStream()), pull.filter((msg) => { var _a; return Ref.isAddress((_a = msg.value.content) === null || _a === void 0 ? void 0 : _a.address); }), pull.asyncMap((x, cb) => setTimeout(() => cb(null, x), 250)), this.pubDiscoveryPausable, pull.drain((msg) => {
                try {
                    const address = Ref.toMultiServerAddress(msg.value.content.address);
                    const key = Ref.getKeyFromAddress(address);
                    if (this.isBlocked([address, { key }])) {
                        this.ssb.conn.forget(address);
                    }
                    else if (!this.ssb.conn.db().has(address)) {
                        this.ssb.conn.stage(address, { key, type: 'pub' });
                        this.ssb.conn.remember(address, {
                            key,
                            type: 'pub',
                            autoconnect: false,
                        });
                    }
                }
                catch (err) {
                    debug('cannot process discovered pub because: %s', err);
                }
            }));
            pull(this.ssb.conn.staging().liveEntries(), pull.drain((staged) => {
                var _a, _b;
                if (this.closed)
                    return;
                const stagedPubs = staged.filter(([, data]) => data.type === 'pub');
                if (stagedPubs.length >= MAX_STAGED_PUBS) {
                    (_a = this.pubDiscoveryPausable) === null || _a === void 0 ? void 0 : _a.pause();
                }
                else {
                    (_b = this.pubDiscoveryPausable) === null || _b === void 0 ? void 0 : _b.resume();
                }
            }));
        }, 1000);
        (_c = timer === null || timer === void 0 ? void 0 : timer.unref) === null || _c === void 0 ? void 0 : _c.call(timer);
    }
    cleanUpDB() {
        const roomsWithMembership = new Set();
        for (let peer of this.ssb.conn.dbPeers()) {
            const [address, { source, type, membership }] = peer;
            if (source === 'local' ||
                source === 'bt' ||
                type === 'lan' ||
                type === 'bt') {
                this.ssb.conn.forget(address);
            }
            if (isDefunct(peer)) {
                this.removeDefunct(address);
            }
            if (type === 'room' && membership) {
                roomsWithMembership.add(address);
            }
        }
        for (let [address, data] of this.ssb.conn.dbPeers()) {
            if (data.type === 'room-endpoint' || data.type === 'room-attendant') {
                if (data.alias &&
                    data.roomAddress &&
                    roomsWithMembership.has(data.roomAddress)) {
                    this.ssb.conn.forget(address);
                }
            }
        }
    }
};
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('sync')
], ConnScheduler.prototype, "start", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('sync')
], ConnScheduler.prototype, "stop", void 0);
ConnScheduler = __decorate([
    (0, secret_stack_decorators_1.plugin)('1.0.0')
], ConnScheduler);
exports.ConnScheduler = ConnScheduler;
