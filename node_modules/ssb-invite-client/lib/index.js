"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const run = require("promisify-tuple");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const clarify = require('clarify-error');
const Ref = require('ssb-ref');
let invite = class invite {
    constructor(ssb) {
        this.accept = async (invite, cb) => {
            if (!this.ssb.conn || !this.ssb.conn.connect || !this.ssb.conn.remember) {
                cb(new Error('ssb-invite-client requires ssb-conn'));
                return;
            }
            const shouldPublish = typeof invite === 'object' && typeof invite.shouldPublish !== 'undefined'
                ? invite.shouldPublish
                : true;
            // parse the code
            const [e0, parsed] = this.parseInvite(invite);
            if (e0)
                return cb(clarify(e0, 'Could not accept invalid invite code'));
            if (!parsed)
                return cb(new Error('Could not parse invite code: ' + invite));
            // connect via SSB CONN
            const addr = parsed.remote;
            const connData = { type: 'pub', autoconnect: true };
            const [e1, rpc] = await run(this.ssb.conn.connect)(addr, connData);
            if (e1)
                return cb(clarify(e1, 'Could not connect to pub'));
            // command the peer to follow me
            const [e2] = await run(rpc.invite.use)({ feed: this.ssb.id });
            if (e2)
                return cb(clarify(e2, 'Invite not accepted by the pub'));
            if (shouldPublish) {
                // follow the peer
                const [e3] = await run(this.ssb.publish)({
                    type: 'contact',
                    following: true,
                    autofollow: true,
                    contact: parsed.key,
                });
                if (e3)
                    return cb(clarify(e3, 'Unable to follow friend behind invite'));
                // announce the pub to my friends
                const [e4] = await run(this.ssb.publish)({
                    type: 'pub',
                    address: parsed,
                });
                if (e4)
                    return cb(clarify(e4, 'Unable to announce pub to my friends'));
            }
            // remember in SSB CONN
            const [e5] = await run(this.ssb.conn.remember)(addr, connData);
            if (e5)
                return cb(clarify(e5, 'Could not store the pub in ssb-conn'));
            cb(null, true);
        };
        this.use = (_opts, cb) => {
            cb(new Error('ssb.invite.use not supported by ' + this.ssb.id));
        };
        this.create = (_opts, cb) => {
            cb(new Error('ssb.invite.create not supported by ' + this.ssb.id));
        };
        this.ssb = ssb;
    }
    parseInvite(input) {
        let invite = input && typeof input === 'object' ? input.invite : input;
        if (typeof invite !== 'string' || !invite) {
            return [new Error('is not a string invite code: ' + invite)];
        }
        // remove surrounding whitespaces and quotes
        invite = invite.trim();
        if (invite.charAt(0) === '"' && invite.charAt(invite.length - 1) === '"') {
            invite = invite.slice(1, -1);
        }
        invite = invite.trim();
        if (!Ref.isInvite(invite)) {
            return [new Error('is not an invite code: ' + invite)];
        }
        if (Ref.isLegacyInvite(invite)) {
            const parts = invite.split('~');
            const parsed = Ref.parseAddress(parts[0]);
            // convert legacy code to multiserver invite code.
            const protocol = parsed.host.endsWith('.onion') ? 'onion:' : 'net:';
            parsed.remote =
                protocol +
                    parsed.host +
                    ':' +
                    parsed.port +
                    '~shs:' +
                    parsed.key.slice(1, -8) +
                    ':' +
                    parts[1];
            return [null, parsed];
        }
        else {
            const parsed = Ref.parseInvite(invite);
            return [null, parsed];
        }
    }
};
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('async')
], invite.prototype, "accept", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('async')
], invite.prototype, "use", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('async')
], invite.prototype, "create", void 0);
invite = __decorate([
    (0, secret_stack_decorators_1.plugin)('1.0.0')
], invite);
module.exports = invite;
