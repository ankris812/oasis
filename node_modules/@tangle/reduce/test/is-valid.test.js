const test = require('tape')
const Reduce = require('../')

const Strategy = require('@tangle/strategy')
const Overwrite = require('@tangle/overwrite')
const SimpleSet = require('@tangle/simple-set')

const strategy = new Strategy({
  title: Overwrite(),
  otherAuthors: SimpleSet()
  // NOTE - recommend using complex-set in production so you can track when an author was added
})

function isValid (context, nextNode) {
  const { accT, graph } = context

  if (!accT) throw new Error('must have initial accT')

  const isAuthor = graph.rootNodes.some(rootNode => rootNode.author === nextNode.author)
  if (isAuthor) return true

  const isOtherAuthor = nextNode.previous.every(key => {
    return accT.otherAuthors[nextNode.author] > 0
    // look at this nodes reporte previous nodes
    // see if the accumulated Transformation state (accT) for that node
    // includes this new nodes author in the list of approved authors

    // NOTE this is a pretty wobbly algorithm, but works for this test
  })
  if (isOtherAuthor) return true

  return false
}

test('opts.isValid', t => {
  //   A   (root)
  //   |
  //   B
  //   |
  //   C

  const A = {
    key: 'A',
    author: '@mix',
    previous: null,
    title: { set: 'my root message' }
  }
  const B = {
    key: 'B',
    author: '@cherese',
    previous: ['A'],
    title: { set: 'nice nice' }
  }
  const C = {
    key: 'C',
    author: '@mix',
    previous: ['B'],
    title: { set: 'nice nice!!!!' }
  }
  t.deepEqual(
    new Reduce(strategy, { nodes: [A, B, C], isValid }).state,
    {
      A: {
        title: { set: 'my root message' },
        otherAuthors: {}
      }
    },
    'ignores invalid nodes'
  )

  const X = {
    key: 'X',
    author: '@mix',
    title: { set: 'my root message' },
    otherAuthors: { '@cherese': 1 },
    previous: null
  }
  const Y = {
    key: 'Y',
    author: '@cherese',
    previous: ['X'],
    title: { set: 'nice nice' }
  }

  t.deepEqual(
    new Reduce(strategy, { nodes: [X, Y], isValid }).state,
    {
      Y: {
        title: { set: 'nice nice' },
        otherAuthors: { '@cherese': 1 }
      }
    },
    'includes valid nodes'
  )

  t.end()
})

// questions:
// - should it just perform an additional check before / after basic tangle validity checks have been made?
// - is this where "is time-traveller" check would be made?
//     - if so might need "nodes so far" / "path" + lookup
//     - mind you reverseMap should get us nodes so far if needed, so perhaps only the lookup + reverseMap
//     - or the graph object
