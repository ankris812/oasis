const test = require('tape')
const Reduce = require('../')

const Strategy = require('@tangle/strategy')
const OverwriteStrategy = require('@tangle/overwrite')

const StringAppendStrategy = () => ({ // stringAppend
  concat: (a, b) => a + b,
  identity: () => '',
  isConflict: (a, b) => a !== b,
  // conflictMerge: (merge, heads) => merge,
  mapToOutput: a => a,
  schema: { type: 'object' }
})

const strategy = new Strategy({
  title: OverwriteStrategy(),
  ouji: StringAppendStrategy()
})

test('reduce (merge)', t => {
  //     A   (root)
  //    / \
  //   B   C

  const A = {
    key: 'A',
    previous: null,
    title: { set: 'my root message' },
    ouji: 'hello'
  }
  const B = {
    key: 'B',
    previous: ['A'],
    ouji: ' mix'
  }
  const C = {
    key: 'C',
    previous: ['A'],
    title: { set: 'edited message' },
    ouji: ' world'
  }
  t.deepEqual(
    new Reduce(strategy, { nodes: [A, B, C] }).state,
    {
      B: {
        title: { set: 'my root message' },
        ouji: 'hello mix'
      },
      C: {
        title: { set: 'edited message' },
        ouji: 'hello world'
      }
    },
    'simple hydra'
  )

  //     A   (root)
  //    / \
  //   B   C
  //    \ /
  //     D
  const D = {
    key: 'D',
    previous: ['B', 'C'],
    title: { set: 'edited and merged!' },
    ouji: 'hello world (mix)'
  }
  // this is a valid merge because it resolves the conflict present between B + C
  // with the title + ouji properties

  t.deepEqual(
    new Reduce(strategy, { nodes: [A, B, C, D] }).state,
    {
      D: {
        title: { set: 'edited and merged!' },
        ouji: 'hello world (mix)'
      }
    },
    'merge with conflict'
  )

  t.end()
})

// TODO
test('reduce (invalid merge)', { skip: true }, t => {
  //     A   (root)
  //    / \
  //   B   C
  //    \ /
  //     Dud  << an invalid merge message

  const A = {
    key: 'A',
    previous: null,
    title: { set: 'my root message' },
    ouji: 'hello'
  }
  const B = {
    key: 'B',
    previous: ['A'],
    ouji: ' mix'
  }
  const C = {
    key: 'C',
    previous: ['A'],
    title: { set: 'edited message' },
    ouji: ' world'
  }
  const Dud = {
    key: 'D',
    previous: ['B', 'C'],
    title: { set: 'edited and merged!' }
    // ouji: identity()
  }
  // this is an invalid merge message because Dud fails to resolve conflict between B + C
  // on the 'ouji' property

  t.deepEqual(
    new Reduce(strategy, { nodes: [A, B, C, Dud] }).state,
    {
      B: {
        title: { set: 'my root message' },
        ouji: 'hello mix'
      },
      C: {
        title: { set: 'edited message' },
        ouji: 'hello world'
      }
    },
    'invalid merge message (merge message is ignored)'
  )

  t.end()
})

// TODO
test('reduce (automerge)', { skip: true }, t => {
  //     A   (root)
  //    / \
  //   B   C
  //   |   |
  //   |   D
  //    \ /
  //     E

  const A = {
    key: 'A',
    previous: null,
    title: { set: 'my root message' },
    ouji: 'hello'
  }
  const B = {
    key: 'B',
    previous: ['A'],
    title: { set: 'one two' },
    ouji: ' mix'
  }
  const C = {
    key: 'C',
    previous: ['A'],
    title: { set: 'one' },
    ouji: ' world'
  }
  const D = {
    key: 'D',
    previous: ['C'],
    title: { set: 'one two' }
  }
  const E = {
    key: 'E',
    previous: ['B', 'D'],
    ouji: 'hello mix-world!'
  }
  // this is an valid because:
  // - 'title' transformations pre-merge are identical, so can automerge
  // - 'ouji' transformations are in conflict, but a resolution is declared

  t.deepEqual(
    new Reduce(strategy, { nodes: [A, B, C, D, E] }).state,
    {
      E: {
        title: { set: 'my root message' },
        ouji: 'hello mix-world!'
      }
    },
    'automerge of identical heads + correct conflict resolution'
  )

  t.end()
})
