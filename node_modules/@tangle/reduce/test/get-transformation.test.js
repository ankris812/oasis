const test = require('tape')
const Reduce = require('../')

const Strategy = require('@tangle/strategy')
const Overwrite = require('@tangle/overwrite')
const Set = require('@tangle/simple-set')

const strategy = new Strategy({
  title: Overwrite(),
  authors: Set(),
  distance: Overwrite({ type: 'number' })
})

test('opts.getTransformation', t => {
  //   A   (root)
  //   |
  //   B

  const A = {
    key: 'A',
    previous: null,
    mutations: {
      title: { set: 'my root message' },
      authors: { mix: 1, luandro: 1 }
    }
  }
  const B = {
    key: 'B',
    previous: ['A'],
    mutations: {
      title: { set: 'my root message' },
      authors: { mix: -1 }
    }
  }

  const getTransformation = (node, d) => {
    return {
      ...node.mutations,
      distance: { set: d }
    }
  }

  t.deepEqual(
    new Reduce(strategy, { nodes: [A, B], getTransformation }).state,
    {
      B: {
        title: { set: 'my root message' },
        authors: { luandro: 1 },
        distance: { set: 1 }
      }
    },
    'custom getTransformation works'
  )

  //   A   (root)
  //   |
  //   B
  //   | \
  //   C  X
  //   |  |
  //   D  |
  //   | /
  //   E

  const C = { key: 'C', previous: ['B'] }
  const D = { key: 'D', previous: ['C'] }
  const X = { key: 'X', previous: ['B'] }
  const E = { key: 'E', previous: ['D', 'X'] }

  t.deepEqual(
    new Reduce(strategy, { nodes: [A, B, C, D, X, E], getTransformation }).state.E.distance,
    { set: 4 },
    'count works'
  )

  t.end()
})
