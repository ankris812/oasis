const Graph = require('@tangle/graph')
const Queue = require('./queue')

module.exports = class Reduce {
  constructor (strategy, opts = {}) {
    this.strategy = strategy

    const {
      nodes = [],
      getTransformation = (node, distance) => node,
      getBacklinks = node => node.previous,
      isValid
    } = opts
    // TODO prune time-travellers
    this.graph = new Graph(nodes, { getBacklinks })
    this.isValid = isValid

    this.getT = (nodeId, distance) => {
      return strategy.mapToPure(
        getTransformation(this.graph.getNode(nodeId), distance)
      )
    }

    this._resolvedState = null
  }

  get state () {
    return this.resolve()
  }

  resolve () {
    if (this._resolvedState) return this._resolvedState

    const { graph, strategy, getT, isValid } = this

    const queue = new Queue()
    // a queue made up of objects { nodeId, accT, d } representing position in graph:
    //   - nodeId = the unique identifier for a node
    //   - accT = the accumulated (concat'd) Transformation up to and including node `nodeId`
    //   - d = distance from root, in a merge it increases to be longer than the longest path

    if (isValid) {
      const initialContext = { accT: strategy.identity(), graph }

      graph.rootNodes.forEach(node => {
        if (!isValid(initialContext, node)) {
          throw new Error('tangle starting node invalid!')
        }
      })
    }

    // seed the queue with starting node(s)
    graph.rootNodeKeys.forEach(key => {
      queue.add({
        nodeId: key,
        accT: getT(key, 0),
        d: 0
      })
    })

    const tips = {
      preMerge: new Map(),
      // a Map of form { [nodeId]: accT }
      // which describes the nodes immediately preceeding a merge-node
      terminal: {}
    }

    while (!queue.isEmpty()) {
      const { nodeId, accT, d } = queue.next()
      // accT is the accumulated Transformation so far
      // (NOT including Transformation stored in key though, that's what we're )

      if (isValid) {
      // check if the next steps are valid before taking them
      // prune here, because this migh change which nodes are new tips / tips
        graph.getLinks(nodeId).forEach(nextId => {
          const nextNodeValid = isValid({ accT, graph }, graph.getNode(nextId))
          if (!nextNodeValid) graph.invalidateKeys([nextId])
        })
      }

      if (graph.isTipNode(nodeId)) {
        tips.terminal[nodeId] = accT
        continue
      }

      graph.getLinks(nodeId).forEach(nextId => {
        if (!graph.isMergeNode(nextId)) {
          queue.add({
            nodeId: nextId,
            accT: strategy.concat(accT, getT(nextId, d + 1)),
            d: d + 1
          })
        // queue up the another node to explore from
        } else {
          tips.preMerge.set(nodeId, { accT, d })

          const requiredNodeIds = graph.getBacklinks(nextId)
          const ready = requiredNodeIds.every(nodeId => tips.preMerge.has(nodeId))
          // check tips.preMerge store to see if we now have the state needed to complete merge

          if (ready) {
          // <----- WIP-start----->
            if (Object.keys(this.strategy._composition).length) {
              // this is for group tangle reducing where we use this machinary,
              // but are not handling any transformations, so "merges" are safe
              console.warn('! WARNING ! - reducing merges safely is not yet fully working')
            }

            const maxD = requiredNodeIds
              .map(nodeId => tips.preMerge.get(nodeId).d)
              .reduce((acc, d) => d > acc ? d : acc, 0)

            const mergeTransformation = getT(nextId, maxD + 1)

            // const preMergeTransformations = requiredNodeIds.map(nodeId => tips.preMerge.get(nodeId).accT)

            // ALGORITHM:
            // is there a conflict between tips (preMergeTransformations) ?
            // - no: concat the tips, then concat result with mergeTransformation
            // - yes: does mergeTransformation resolves tips conflict?
            //    - yes: do it (TODO decide what merge is in the case of composition other than overwrite
            //    - no: throw out the merge....
            //
            //  functions needed:
            //  - [ ] IsConflict(composition)(tips)
            //  - [ ] Concat(composition)(tips)
            //  - [ ] IsValidMerge
            //
            //  NOTE to detect a conflict I think we only want to be comparing the divergence in branches
            //  e.g.
            //      A        ]
            //      |        ]--- common history, do not compare
            //      B        ]
            //     / \
            //    C   D      ]--- divergent history, compare C + D for conflict
            //     \ /
            //      E
            //
            //

            queue.add({
              nodeId: nextId,
              // accT: nextT
              accT: mergeTransformation,
              d: maxD + 1
            })
            // this just treats merge like an overwrite (ignoring all transformations so far)
            // and for all properties, which is wrong because it ignores invalid merges, and over-writes un-named values with identity

          // <----- WIP-end----->
          }
        }
      })
    }

    this._resolvedState = tips.terminal
    return this._resolvedState
  }

  addNodes (nodes) {
    this._resolvedState = null
    this.graph.addNodes(nodes)
    // idea: preserve the more state from initial resolve and find a way to re-ignite the the resolving path
    // This is challenging because you don't know which new nodes attach where....
  }
}
