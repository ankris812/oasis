const Validator = require('is-my-json-valid')

// This made for modelling Sets made up of Strings
//
// I've chosen to make it *commutative* (transformation order doesn't matter)
// Implications of this are:
// - no merge conflicts!
// - more concise transformations
// - reified output is always alphabetically sorted

const IDENTITY = {}

module.exports = function SimpleSet (idPattern) {
  // transformations are of form:
  // - { String: Integer }
  // - {} (identity)

  if (!idPattern) idPattern = '^.+$'
  const schema = {
    type: 'object',
    patternProperties: {
      [idPattern]: { type: 'integer' }
    },
    additionalProperties: false
  }
  const isValid = Validator(schema)

  function mapToOutput (T) {
    if (!isValid(T)) throw Error('reify expects valid transformation')

    return Object.entries(T)
      .map(([entry, weight]) => {
        return weight > 0 ? entry : null
      })
      .filter(Boolean)
      .sort()
  }

  function concat (a, b) {
    if (!isValid(a)) throw Error('concat expects valid transformation')
    if (!isValid(b)) throw Error('concat expects valid transformation')

    const newT = Object.assign({}, a)
    Object.entries(b).forEach(([entry, weight]) => {
      if (entry in newT) {
        const newWeight = newT[entry] + weight

        if (newWeight === 0) delete newT[entry]
        else newT[entry] = newWeight
      } else {
        newT[entry] = weight
      }
    })

    return newT
  }

  /*
    gets the new state from the current state + a change for a simple set
  */
  function mapFromInput (currentT, input) {
    if (input === null || input === undefined) return undefined

    if (typeof input !== 'object') throw new Error('input must be an object')
    if (typeof input === 'object' && !Object.keys(input).length) throw new Error('input must be an object of shape { add: [String], remove: [String] }')

    const { add = [], remove = [] } = input

    if (add && !Array.isArray(add)) throw new Error('simpleSet.add must be an Array of Strings')
    if (remove && !Array.isArray(remove)) throw new Error('simpleSet.remove must be an Array of Strings')

    const change = {}

    add.forEach(key => {
      if (currentT[key] !== undefined) {
        if (currentT[key] < 1) {
          change[key] = -1 * currentT[key] + 1
        }
      } else {
        change[key] = 1
      }
    })

    remove.forEach(key => {
      if (currentT[key] !== undefined) {
        if (currentT[key] >= 1) {
          change[key] = -1 * currentT[key]
        }
      }
    })

    return change
  }

  function isConflict () {
    return false
  }

  function isValidMerge () {
    return true
  }

  // Concat the history of the mergenode in any order
  function merge (graph, mergeNodeId, field) {
    return [mergeNodeId, ...graph.getHistory(mergeNodeId)]
      .map((key) => {
        if (field in graph.getNode(key).data) return graph.getNode(key).data[field]
        else return {}
      })
      .reduce((a, b) => { return concat(a, b) })
  }

  return {
    schema,
    isValid,
    identity: () => IDENTITY,
    concat,
    mapFromInput,
    mapToOutput,
    isConflict,
    isValidMerge,
    merge
  }
}
