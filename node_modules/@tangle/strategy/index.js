const Validator = require('is-my-json-valid')

const Schema = require('./schema')
const Concat = require('./concat')
const isValidStrategy = require('./is-valid-strategy')
const map = require('./map')

class Strategy {
  static isValid (strategy) {
    const result = isValidStrategy(strategy)
    Strategy.isValid.error = isValidStrategy.error
    return result
  }

  static isValidComposition (composition) {
    const errors = []
    Object.entries(composition).forEach(([name, strategy]) => {
      if (!isValidStrategy(strategy, name)) {
        errors.push(`field "${name}" has invalid strategy`)
      }
    })
    if (errors.length) {
      Strategy.isValidComposition.error = new Error([
        'Invalid composition:',
        ...errors
      ].join('\n - '))

      return false
    }

    Strategy.isValidComposition.error = null
    return true
  }

  constructor (composition) {
    Strategy.isValidComposition(composition)

    this._composition = composition
    this.schema = Schema(composition)

    this.isValid = Validator(this.schema, { verbose: true })
    this.concat = Concat(composition)
    this.mapFromInput = map.FromInput(composition) // input => T
    this.mapToOutput = map.ToOutput(composition) //   T => output
    this.mapToPure = map.ToPure(composition) //       t => T
  }

  /* Methods */
  identity () { return this.mapToPure({}) }
  // isValid
  // concat
  // mapFromInput
  // mapToOutput
  // mapToPure

  /* Getters */
  get fields () { return Object.keys(this._composition).sort() }
  // schema

  /* future methods ? */

  // isConflict: IsConflict(composition),
  // isValidMerge: IsValidMerge(composition)
}

module.exports = Strategy

/* WIP */

// function IsConflict (composition) {
//   return function (heads) {
//     heads = an Array of Transformations you're considering merging
//             each entry is the accumulated Transformation of each tip of a graph
//
//     return Object.entries(composition).some(([field, strategy]) => {
//       return strategy.isConflict(heads)
//     })
//   }
// }

// function isValidTransformation (composition) {
//
// }

// function isValidMerge (composition) {
//   return function (heads, merge) {
//     // heads = an Array of Transformations you're considering merging
//     // merge = a Transformation which is proposed to merge the heads together
//
//     return Object.entries(composition).every(([field, strategy]) => {
//       const headsTs = heads.map(head => head[field] || strategy.identity())
//       const mergeT = merge[field] || strategy.identity()
//
//       if (composition.isConflict(headsTs)) return mergeT !== composition.identity()
//       // if there's a conflict, the resolving merge Transformation (mergeT)
//       // must resolve the conflict (i.e. cannot be the identtiy Transformation)
//
//       return true
//     })
//   }
// }
