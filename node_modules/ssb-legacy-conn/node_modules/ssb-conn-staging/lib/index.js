"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var pull = require('pull-stream');
var cat = require('pull-cat');
var Notify = require('pull-notify');
var msAddress = require('multiserver-address');
var debug = require('debug')('ssb:conn-staging');
var ConnStaging = (function () {
    function ConnStaging() {
        this._peers = new Map();
        this._closed = false;
        this._notifyEvent = Notify();
        this._notifyEntries = Notify();
    }
    ConnStaging.prototype._assertNotClosed = function () {
        if (this._closed) {
            throw new Error('This ConnStaging instance is closed, create a new one.');
        }
    };
    ConnStaging.prototype._assertValidAddress = function (address) {
        if (!msAddress.check(address)) {
            throw new Error('The given address is not a valid multiserver-address');
        }
    };
    ConnStaging.prototype._updateLiveEntries = function () {
        this._notifyEntries(Array.from(this._peers.entries()));
    };
    ConnStaging.prototype.stage = function (address, data) {
        this._assertNotClosed();
        this._assertValidAddress(address);
        var now = Date.now();
        if (this._peers.has(address)) {
            var previous = this._peers.get(address);
            this._peers.set(address, __assign({}, previous, { stagingUpdated: now }, data));
            this._updateLiveEntries();
            return false;
        }
        else {
            this._peers.set(address, __assign({ stagingBirth: now, stagingUpdated: now }, data));
            debug('staged peer %s', address);
            this._notifyEvent({ type: 'staged', address: address });
            this._updateLiveEntries();
            return true;
        }
    };
    ConnStaging.prototype.unstage = function (address) {
        this._assertNotClosed();
        this._assertValidAddress(address);
        if (!this._peers.has(address))
            return false;
        this._peers.delete(address);
        debug('unstaged peer %s', address);
        this._notifyEvent({ type: 'unstaged', address: address });
        this._updateLiveEntries();
        return true;
    };
    ConnStaging.prototype.entries = function () {
        this._assertNotClosed();
        return this._peers.entries();
    };
    ConnStaging.prototype.liveEntries = function () {
        this._assertNotClosed();
        return cat([
            pull.values([Array.from(this._peers.entries())]),
            this._notifyEntries.listen(),
        ]);
    };
    ConnStaging.prototype.listen = function () {
        this._assertNotClosed();
        return this._notifyEvent.listen();
    };
    ConnStaging.prototype.close = function () {
        this._closed = true;
        this._notifyEvent.end();
        this._peers.clear();
        debug('closed the ConnStaging instance');
    };
    return ConnStaging;
}());
module.exports = ConnStaging;
