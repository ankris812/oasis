"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
function passesExpBackoff(step, max, timestamp) {
    if (max === void 0) { max = Infinity; }
    if (timestamp === void 0) { timestamp = Date.now(); }
    return function (_a) {
        var _b = __read(_a, 2), _addr = _b[0], data = _b[1];
        var prevAttempt = data.stateChange || 0;
        var numFailures = data.failure || 0;
        var expBackoff = Math.min(Math.pow(2, numFailures) * step, max);
        var nextAttempt = prevAttempt + expBackoff;
        return nextAttempt < timestamp;
    };
}
exports.passesExpBackoff = passesExpBackoff;
function passesGroupDebounce(groupMin, timestamp) {
    if (timestamp === void 0) { timestamp = Date.now(); }
    return function (group) {
        var newestStateChange = group.reduce(function (max, _a) {
            var _b = __read(_a, 2), _addr = _b[0], p = _b[1];
            return Math.max(max, p.stateChange || 0);
        }, 0);
        var minTimeThreshold = newestStateChange + groupMin;
        if (timestamp < minTimeThreshold)
            return [];
        else
            return group;
    };
}
exports.passesGroupDebounce = passesGroupDebounce;
