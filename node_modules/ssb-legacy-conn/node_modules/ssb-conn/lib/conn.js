"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ConnDB = require("ssb-conn-db");
const ConnHub = require("ssb-conn-hub");
const ConnStaging = require("ssb-conn-staging");
const ConnQuery = require("ssb-conn-query");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const interpool_glue_1 = require("./interpool-glue");
const msAddress = require('multiserver-address');
const ping = require('pull-ping');
let CONN = class CONN {
    constructor(ssb, cfg) {
        this.remember = (address, data = {}) => {
            this.assertValidAddress(address);
            this.db.set(address, data);
        };
        this.forget = (address) => {
            this.assertValidAddress(address);
            this.db.delete(address);
        };
        this.dbPeers = () => this.db.entries();
        this.connect = (address, second, third) => {
            if (typeof second === 'function' && typeof third === 'function') {
                throw new Error('CONN.connect() received incorrect arguments');
            }
            const cb = (typeof third === 'function' ? third : second);
            const data = (typeof third === 'function' ? second : undefined);
            try {
                this.assertValidAddress(address);
            }
            catch (err) {
                cb(err);
                return;
            }
            this.hub
                .connect(address, data)
                .then(result => cb && cb(null, result), err => cb && cb(err));
        };
        this.disconnect = (address, cb) => {
            try {
                this.assertValidAddress(address);
            }
            catch (err) {
                cb(err);
                return;
            }
            this.hub
                .disconnect(address)
                .then(result => cb && cb(null, result), err => cb && cb(err));
        };
        this.peers = () => this.hub.liveEntries();
        this.stage = (address, data = { type: 'internet' }) => {
            if (!!this.hub.getState(address))
                return false;
            return this.staging.stage(address, data);
        };
        this.unstage = (address) => {
            return this.staging.unstage(address);
        };
        this.stagedPeers = () => this.staging.liveEntries();
        this.query = () => this.connQuery;
        this.start = () => {
            return this.startScheduler();
        };
        this.stop = () => {
            this.stopScheduler();
        };
        this.ping = () => {
            const MIN = 10e3;
            const DEFAULT = 5 * 60e3;
            const MAX = 30 * 60e3;
            let timeout = (this.config.timers && this.config.timers.ping) || DEFAULT;
            timeout = Math.max(MIN, Math.min(timeout, MAX));
            return ping({ timeout });
        };
        this.internalConnDB = () => this.db;
        this.internalConnHub = () => this.hub;
        this.internalConnStaging = () => this.staging;
        this.ssb = ssb;
        this.config = cfg;
        this.db = new ConnDB({ path: this.config.path, writeTimeout: 10e3 });
        this.hub = new ConnHub(this.ssb);
        this.staging = new ConnStaging();
        this.connQuery = new ConnQuery(this.db, this.hub, this.staging);
        this.initialize();
    }
    initialize() {
        this.setupCloseHook();
        this.maybeAutoStartScheduler();
        interpool_glue_1.interpoolGlue(this.db, this.hub, this.staging);
    }
    setupCloseHook() {
        const that = this;
        this.ssb.close.hook(function (fn, args) {
            that.stopScheduler();
            that.db.close();
            that.hub.close();
            that.staging.close();
            return fn.apply(this, args);
        });
    }
    maybeAutoStartScheduler() {
        if (this.config.conn && this.config.conn.autostart !== false) {
            this.startScheduler();
        }
    }
    startScheduler() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.db.loaded();
            if (this.ssb.connScheduler) {
                this.ssb.connScheduler.start();
            }
            else {
                setTimeout(() => {
                    if (this.ssb.connScheduler) {
                        this.ssb.connScheduler.start();
                    }
                    else {
                        console.error('There is no ConnScheduler! ' +
                            'The CONN plugin will remain in manual mode.');
                    }
                }, 100);
            }
        });
    }
    stopScheduler() {
        if (this.ssb.connScheduler)
            this.ssb.connScheduler.stop();
    }
    assertValidAddress(address) {
        if (!msAddress.check(address)) {
            throw new Error('The given address is not a valid multiserver-address');
        }
    }
};
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "remember", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "forget", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "dbPeers", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async')
], CONN.prototype, "connect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async')
], CONN.prototype, "disconnect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], CONN.prototype, "peers", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "stage", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "unstage", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], CONN.prototype, "stagedPeers", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "query", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "start", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "stop", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('duplex', { anonymous: 'allow' })
], CONN.prototype, "ping", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "internalConnDB", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "internalConnHub", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "internalConnStaging", void 0);
CONN = __decorate([
    secret_stack_decorators_1.plugin('1.0.0')
], CONN);
exports.CONN = CONN;
