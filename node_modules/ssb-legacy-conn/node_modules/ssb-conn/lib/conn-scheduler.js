"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ConnQuery = require("ssb-conn-query");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const pull = require('pull-stream');
const ip = require('ip');
const onWakeup = require('on-wakeup');
const onNetwork = require('on-change-network');
const hasNetwork = require('has-network');
const Ref = require('ssb-ref');
const Keys = require('ssb-keys');
const debug = require('debug')('ssb:conn:scheduler');
require('zii');
let lastCheck = 0;
let lastValue = null;
function hasNetworkDebounced() {
    if (lastCheck + 1e3 < Date.now()) {
        lastCheck = Date.now();
        lastValue = hasNetwork();
    }
    return lastValue;
}
function isOffline(p) {
    if (ip.isLoopback(p[1].host) || p[1].host == 'localhost')
        return false;
    else
        return !hasNetworkDebounced();
}
const canBeConnected = (p) => !isOffline(p);
function isLocal(p) {
    return (!ip.isLoopback(p[1].host) &&
        ip.isPrivate(p[1].host) &&
        (p[1].source === 'local' || p[1].type === 'lan'));
}
function isLegacy(peer) {
    return hasSuccessfulAttempts(peer) && !hasPinged(peer);
}
function take(n) {
    return (arr) => arr.slice(0, Math.max(n, 0));
}
const { passesExpBackoff, passesGroupDebounce, hasNoAttempts, hasOnlyFailedAttempts, hasPinged, hasSuccessfulAttempts, sortByStateChange, } = ConnQuery;
const minute = 60e3;
const hour = 60 * 60e3;
let ConnScheduler = class ConnScheduler {
    constructor(ssb, config) {
        this.weBlockThem = ([_addr, data]) => {
            if (!data || !data.key)
                return false;
            return this.hops[data.key] === -1;
        };
        this.weFollowThem = ([_addr, data]) => {
            if (!data || !data.key)
                return false;
            return this.hops[data.key] > 0;
        };
        this.start = () => {
            if (!this.closed)
                return;
            this.closed = false;
            for (let [address, { source, type }] of this.ssb.conn.dbPeers()) {
                if (source === 'local' ||
                    source === 'bt' ||
                    type === 'lan' ||
                    type === 'bt') {
                    this.ssb.conn.forget(address);
                }
            }
            this.populateWithSeeds();
            this.setupPubDiscovery();
            this.setupLanDiscovery();
            this.setupBluetoothDiscovery();
            this.updateHops();
            const int = setInterval(() => this.updateConnectionsSoon(), 2e3);
            if (int.unref)
                int.unref();
            onWakeup(() => this.hub.reset());
            onNetwork(() => this.hub.reset());
            pull(this.hub.listen(), pull.filter((ev) => ev.type === 'disconnected'), pull.drain(() => this.updateConnectionsSoon(400)));
            this.updateConnectionsNow();
        };
        this.stop = () => {
            if (this.ssb.lan && this.ssb.lan.stop)
                this.ssb.lan.stop();
            this.hub.reset();
            this.closed = true;
        };
        this.ssb = ssb;
        this.config = config;
        this.hub = this.ssb.conn.internalConnHub();
        this.closed = true;
        this.lastMessageAt = 0;
        this.hasScheduledAnUpdate = false;
        this.myCapsHash = Keys.hash(config.caps.shs);
        this.hops = {};
        this.ssb.post((msg) => {
            if (msg.value.author != this.ssb.id) {
                this.lastMessageAt = Date.now();
            }
            if (msg.value.content && msg.value.content.type === 'contact') {
                this.updateHops();
            }
        });
    }
    updateHops() {
        if (this.ssb.friends && this.ssb.friends.hops) {
            this.ssb.friends.hops((err, hops) => {
                if (err) {
                    debug('unable to call ssb.friends.hops: %s', err);
                    return;
                }
                this.hops = hops;
            });
        }
        else {
            debug('Warning: ssb-friends is missing, scheduling will miss some info');
        }
    }
    conf(name, def) {
        if (this.config.gossip == null)
            return def;
        const value = this.config.gossip[name];
        return value == null || value === '' ? def : value;
    }
    isCurrentlyDownloading() {
        return this.lastMessageAt && this.lastMessageAt > Date.now() - 500;
    }
    updateTheseConnections(test, opts) {
        const query = this.ssb.conn.query();
        const peersUp = query.peersInConnection().filter(test);
        const peersDown = query.peersConnectable('db').filter(test);
        const { quota, backoffStep, backoffMax, groupMin } = opts;
        const excess = peersUp.length > quota * 2 ? peersUp.length - quota : 0;
        const freeSlots = Math.max(quota - peersUp.length, 0);
        peersUp
            .z(sortByStateChange)
            .z(take(excess))
            .forEach(([addr]) => this.hub.disconnect(addr));
        peersDown
            .filter(p => !this.weBlockThem(p))
            .filter(canBeConnected)
            .z(passesGroupDebounce(groupMin))
            .filter(passesExpBackoff(backoffStep, backoffMax))
            .z(sortByStateChange)
            .z(take(freeSlots))
            .forEach(([addr, peer]) => this.hub.connect(addr, peer));
    }
    updateConnectionsNow() {
        if (!this.ssb.ready() || this.isCurrentlyDownloading())
            return;
        if (this.conf('seed', true)) {
            this.updateTheseConnections(p => p[1].source === 'seed', {
                quota: 3,
                backoffStep: 2e3,
                backoffMax: 10 * minute,
                groupMin: 1e3,
            });
        }
        this.updateTheseConnections(hasPinged, {
            quota: 2,
            backoffStep: 10e3,
            backoffMax: 10 * minute,
            groupMin: 5e3,
        });
        this.updateTheseConnections(hasNoAttempts, {
            quota: 2,
            backoffStep: 30e3,
            backoffMax: 30 * minute,
            groupMin: 15e3,
        });
        this.updateTheseConnections(hasOnlyFailedAttempts, {
            quota: 3,
            backoffStep: 1 * minute,
            backoffMax: 3 * hour,
            groupMin: 5 * minute,
        });
        this.updateTheseConnections(isLegacy, {
            quota: 1,
            backoffStep: 4 * minute,
            backoffMax: 3 * hour,
            groupMin: 5 * minute,
        });
        this.ssb.conn
            .query()
            .peersConnectable('staging')
            .filter(this.weFollowThem)
            .z(take(5))
            .forEach(([addr, data]) => this.hub.connect(addr, data));
        this.ssb.conn
            .query()
            .peersInConnection()
            .filter(this.weBlockThem)
            .forEach(([addr]) => this.hub.disconnect(addr));
        this.ssb.conn
            .query()
            .peersConnectable('staging')
            .filter(([, data]) => data.type === 'lan')
            .filter(([, data]) => data.stagingUpdated + 10e3 < Date.now())
            .forEach(([addr]) => this.ssb.conn.unstage(addr));
        this.ssb.conn
            .query()
            .peersConnectable('staging')
            .filter(([, data]) => data.type === 'bt')
            .filter(([, data]) => data.stagingUpdated + 30e3 < Date.now())
            .forEach(([addr]) => this.ssb.conn.unstage(addr));
        this.ssb.conn
            .query()
            .peersInConnection()
            .filter(peer => {
            const permanent = hasPinged(peer) || isLocal(peer);
            return !permanent || this.hub.getState(peer[0]) === 'connecting';
        })
            .filter(peer => peer[1].stateChange + 10e3 < Date.now())
            .forEach(([addr]) => this.hub.disconnect(addr));
    }
    updateConnectionsSoon(period = 1000) {
        if (this.closed)
            return;
        if (this.hasScheduledAnUpdate)
            return;
        const fuzzyPeriod = period * 0.5 + period * Math.random();
        this.hasScheduledAnUpdate = true;
        const timer = setTimeout(() => {
            this.updateConnectionsNow();
            this.hasScheduledAnUpdate = false;
        }, fuzzyPeriod);
        if (timer.unref)
            timer.unref();
    }
    populateWithSeeds() {
        const seeds = this.config.seeds;
        (Array.isArray(seeds) ? seeds : [seeds]).filter(Boolean).forEach(addr => {
            this.ssb.gossip.add(addr, 'seed');
        });
    }
    setupPubDiscovery() {
        if (!this.config.gossip ||
            (this.config.gossip.autoPopulate !== false &&
                this.config.gossip.pub !== false)) {
            pull(this.ssb.messagesByType({ type: 'pub', live: true, keys: false }), pull.filter((msg) => !msg.sync), pull.filter((msg) => msg.content &&
                msg.content.address &&
                Ref.isAddress(msg.content.address)), pull.drain((msg) => {
                this.ssb.gossip.add(msg.content.address, 'pub');
            }));
        }
    }
    setupBluetoothDiscovery() {
        if (this.ssb.bluetooth && this.ssb.bluetooth.nearbyScuttlebuttDevices) {
            pull(this.ssb.bluetooth.nearbyScuttlebuttDevices(1000), pull.drain(({ discovered }) => {
                for (const btPeer of discovered) {
                    const address = `bt:${btPeer.remoteAddress.split(':').join('')}` +
                        '~' +
                        `shs:${btPeer.id.replace(/^\@/, '').replace(/\.ed25519$/, '')}`;
                    this.ssb.conn.stage(address, {
                        type: 'bt',
                        note: btPeer.displayName,
                        key: btPeer.id,
                    });
                }
            }));
        }
        else {
            debug('Warning: ssb-bluetooth is missing, scheduling will miss some info');
        }
    }
    setupLanDiscovery() {
        if (this.ssb.lan && this.ssb.lan.start && this.ssb.lan.discoveredPeers) {
            pull(this.ssb.lan.discoveredPeers(), pull.drain(({ address, capsHash, verified }) => {
                const peer = Ref.parseAddress(address);
                const isLegacy = !capsHash;
                const capsHashOkay = isLegacy || capsHash === this.myCapsHash;
                const verifiedOkay = isLegacy || verified;
                if (peer && peer.key && capsHashOkay && verifiedOkay) {
                    this.ssb.conn.stage(address, { type: 'lan', key: peer.key });
                }
            }));
            this.ssb.lan.start();
        }
        else {
            debug('Warning: ssb-lan is missing, scheduling will miss some info');
        }
    }
};
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], ConnScheduler.prototype, "start", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], ConnScheduler.prototype, "stop", void 0);
ConnScheduler = __decorate([
    secret_stack_decorators_1.plugin('1.0.0')
], ConnScheduler);
exports.ConnScheduler = ConnScheduler;
