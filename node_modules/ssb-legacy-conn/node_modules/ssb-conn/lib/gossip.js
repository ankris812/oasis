"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const secret_stack_decorators_1 = require("secret-stack-decorators");
const pull = require('pull-stream');
const Notify = require('pull-notify');
const ref = require('ssb-ref');
function isPeerObject(o) {
    return o && 'object' == typeof o;
}
function toBase64(s) {
    if (typeof s === 'string')
        return s.substring(1, s.indexOf('.'));
    else
        return s.toString('base64');
}
function toAddressString(address) {
    if (isPeerObject(address)) {
        if (ref.isAddress(address.address))
            return address.address;
        if (address.source === 'dht') {
            return (['dht', address.host].join(':') + '~' + 'noauth');
        }
        let protocol = 'net';
        if (address.host && address.host.endsWith('.onion'))
            protocol = 'onion';
        return ([protocol, address.host, address.port].join(':') +
            '~' +
            ['shs', toBase64(address.key)].join(':'));
    }
    return address;
}
function isDhtAddress(addr) {
    return typeof addr === 'string' && addr.substr(0, 4) === 'dht:';
}
function parseDhtAddress(addr) {
    const [transport] = addr.split('~');
    const [dhtTag, seed, remoteId] = transport.split(':');
    if (dhtTag !== 'dht')
        throw new Error('Invalid DHT address ' + addr);
    return {
        host: seed + ':' + remoteId,
        port: 0,
        key: remoteId[0] === '@' ? remoteId : '@' + remoteId,
        source: 'dht',
    };
}
function parseAddress(address) {
    if (isDhtAddress(address)) {
        return parseDhtAddress(address);
    }
    const legacyParsing = ref.parseAddress(address);
    if (legacyParsing) {
        return legacyParsing;
    }
    else if (ref.isAddress(address)) {
        return { key: ref.getKeyFromAddress(address) };
    }
}
function validateAddr(addr) {
    if (!addr || (typeof addr !== 'object' && typeof addr !== 'string')) {
        throw new Error('address should be an object or string');
    }
    const addressString = typeof addr === 'string' ? addr : toAddressString(addr);
    const parsed = typeof addr === 'object' ? addr : parseAddress(addressString);
    if (!parsed.key)
        throw new Error('address must have ed25519 key');
    if (!ref.isFeed(parsed.key))
        throw new Error('key must be ed25519 public id');
    return [addressString, parsed];
}
function inferSource(address) {
    return address.startsWith('net:') ? 'local' : 'manual';
}
let Gossip = class Gossip {
    constructor(ssb) {
        this.peers = () => {
            console.error('DEPRECATED gossip.peers() was called. Use ssb-conn instead');
            const peers = Array.from(this.connDB.entries()).map(([address, data]) => {
                return Object.assign({}, data, { address, state: this.connHub.getState(address) });
            });
            for (const [address, data] of this.connHub.entries()) {
                if (!this.connDB.has(address)) {
                    const [, parsed] = validateAddr(address);
                    peers.push(Object.assign({}, data, parsed, { address, source: inferSource(address) }));
                }
            }
            return peers;
        };
        this.get = (addr) => {
            console.error('DEPRECATED gossip.get() was called. Use ssb-conn instead');
            if (ref.isFeed(addr)) {
                for (let [address, data] of this.connDB.entries()) {
                    if (data.key === addr) {
                        return Object.assign({}, data, { address });
                    }
                }
                return undefined;
            }
            const [addressString] = validateAddr(addr);
            const peer = this.connDB.get(addressString);
            if (!peer)
                return undefined;
            else {
                return Object.assign({ address: addressString, state: this.connHub.getState(addressString) }, peer);
            }
        };
        this.connect = (addr, cb) => {
            console.error('DEPRECATED gossip.connect() was called. Use ssb-conn instead');
            let addressString;
            try {
                const inputAddr = ref.isFeed(addr) ? this.idToAddr(addr) : addr;
                [addressString] = validateAddr(inputAddr);
            }
            catch (err) {
                return cb(err);
            }
            this.add(addressString, 'manual');
            this.conn.connect(addressString, cb);
        };
        this.disconnect = (addr, cb) => {
            console.error('DEPRECATED gossip.disconnect() was called. Use ssb-conn instead');
            let addressString;
            try {
                const inputAddr = ref.isFeed(addr) ? this.idToAddr(addr) : addr;
                [addressString] = validateAddr(inputAddr);
            }
            catch (err) {
                return cb(err);
            }
            this.conn.disconnect(addressString, cb);
        };
        this.changes = () => {
            console.error('DEPRECATED gossip.changes() was called. Use ssb-conn instead');
            return this.notify.listen();
        };
        this.add = (addr, source) => {
            console.error('DEPRECATED gossip.add() was called. Use ssb-conn instead');
            const [addressString, parsed] = validateAddr(addr);
            if (parsed.key === this.ssb.id)
                return;
            if (source === 'local') {
                console.error('gossip.add(p, "local") from ssb-local is deprecated, ' +
                    'this only supports ssb-lan');
                return;
            }
            if (this.connDB.has(addressString)) {
                return this.connDB.get(addressString);
            }
            else {
                this.connDB.set(addressString, {
                    host: parsed.host,
                    port: parsed.port,
                    key: parsed.key,
                    address: addressString,
                    source: source,
                });
                this.notify({
                    type: 'discover',
                    peer: Object.assign({}, parsed, { state: this.connHub.getState(addressString), source: source || 'manual' }),
                    source: source || 'manual',
                });
                return this.connDB.get(addressString) || parsed;
            }
        };
        this.remove = (addr) => {
            console.error('DEPRECATED gossip.remove() was called. Use ssb-conn instead');
            const [addressString] = validateAddr(addr);
            this.connHub.disconnect(addressString);
            this.connStaging.unstage(addressString);
            const peer = this.connDB.get(addressString);
            if (!peer)
                return;
            this.connDB.delete(addressString);
            this.notify({ type: 'remove', peer: peer });
        };
        this.ping = () => this.conn.ping();
        this.reconnect = () => {
            console.error('DEPRECATED gossip.reconnect() was called. Use ssb-conn instead');
            this.connHub.reset();
        };
        this.enable = (type) => {
            console.error('UNSUPPORTED gossip.enable("' + type + '") was ignored');
        };
        this.disable = (type) => {
            console.error('UNSUPPORTED gossip.disable("' + type + '") was ignored');
        };
        this.ssb = ssb;
        this.notify = Notify();
        this.conn = this.ssb.conn;
        this.connDB = this.conn.internalConnDB();
        this.connHub = this.conn.internalConnHub();
        this.connStaging = this.conn.internalConnStaging();
        this.setupConnectionListeners();
        this.conn.start();
    }
    setupConnectionListeners() {
        pull(this.connHub.listen(), pull.drain((ev) => {
            if (ev.type === 'connecting-failed')
                this.onConnectingFailed(ev);
            if (ev.type === 'connected')
                this.onConnected(ev);
            if (ev.type === 'disconnected')
                this.onDisconnected(ev);
        }));
    }
    onConnectingFailed(ev) {
        const peer = Object.assign({ state: ev.type, address: ev.address, key: ev.key }, this.connDB.get(ev.address));
        this.notify({ type: 'connect-failure', peer });
    }
    onConnected(ev) {
        const peer = Object.assign({ state: ev.type, address: ev.address, key: ev.key }, this.connDB.get(ev.address));
        if (!this.connDB.has(ev.address))
            peer.source = inferSource(ev.address);
        this.notify({ type: 'connect', peer });
    }
    onDisconnected(ev) {
        const peer = Object.assign({ state: ev.type, address: ev.address, key: ev.key }, this.connDB.get(ev.address));
        this.notify({ type: 'disconnect', peer });
    }
    idToAddr(id) {
        const addr = this.connDB.getAddressForId(id);
        if (!addr) {
            throw new Error('no known address for peer:' + id);
        }
        return addr;
    }
};
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "peers", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "get", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async')
], Gossip.prototype, "connect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async')
], Gossip.prototype, "disconnect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], Gossip.prototype, "changes", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "add", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "remove", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('duplex', { anonymous: 'allow' })
], Gossip.prototype, "ping", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "reconnect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "enable", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "disable", void 0);
Gossip = __decorate([
    secret_stack_decorators_1.plugin('1.0.0')
], Gossip);
exports.Gossip = Gossip;
