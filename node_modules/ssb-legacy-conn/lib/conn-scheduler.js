"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const query_1 = require("ssb-conn/lib/types/query");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const pull = require('pull-stream');
const ip = require('ip');
const onWakeup = require('on-wakeup');
const onNetwork = require('on-change-network');
const hasNetwork = require('has-network');
const ref = require('ssb-ref');
require('zii');
function noop() { }
function not(fn) {
    return function (e) {
        return !fn(e);
    };
}
function and(...args) {
    return (value) => args.every((fn) => fn.call(null, value));
}
let lastCheck = 0;
let lastValue = null;
function hasNetworkDebounced() {
    if (lastCheck + 1e3 < Date.now()) {
        lastCheck = Date.now();
        lastValue = hasNetwork();
    }
    return lastValue;
}
function isOffline(p) {
    if (ip.isLoopback(p[1].host) || p[1].host == 'localhost')
        return false;
    else
        return !hasNetworkDebounced();
}
function notBluetooth(p) {
    return !p[0].startsWith('bt:');
}
const canBeConnected = not(isOffline);
function isLocal(p) {
    return (!ip.isLoopback(p[1].host) &&
        ip.isPrivate(p[1].host) &&
        (p[1].source === 'local' || p[1].type === 'lan'));
}
function isLegacy(peer) {
    return hasSuccessfulAttempts(peer) && !hasPinged(peer);
}
function isFriend(p) {
    return p[1].source === 'friends';
}
function take(n) {
    return (arr) => arr.slice(0, Math.max(n, 0));
}
const { passesExpBackoff, passesGroupDebounce, hasNoAttempts, hasOnlyFailedAttempts, hasPinged, hasSuccessfulAttempts, sortByStateChange, } = query_1.ConnQuery;
const minute = 60e3;
const hour = 60 * 60e3;
let ConnScheduler = class ConnScheduler {
    constructor(ssb, config) {
        this.start = () => {
            if (!this.closed)
                return;
            this.closed = false;
            onWakeup(() => this.hub.reset());
            onNetwork(() => this.hub.reset());
            pull(this.hub.listen(), pull.filter((ev) => ev.type === 'disconnected'), pull.drain(() => this.updateConnectionsSoon(), (...args) => console.warn('[gossip/dc] warning: this can happen if the database closes', args)));
            const int = setInterval(() => this.updateConnectionsSoon(), 2e3);
            if (int.unref)
                int.unref();
            this.updateConnectionsSoon();
            if (this.config.offline) {
                console.log('Running in offline mode: gossip disabled');
            }
            else {
                const seeds = this.config.seeds;
                (Array.isArray(seeds) ? seeds : [seeds]).filter(Boolean).forEach(addr => {
                    this.ssb.gossip.add(addr, 'seed');
                });
                if (!this.config.gossip ||
                    (this.config.gossip.autoPopulate !== false &&
                        this.config.gossip.pub !== false)) {
                    pull(this.ssb.messagesByType({ type: 'pub', live: true, keys: false }), pull.filter((msg) => !msg.sync), pull.filter((msg) => msg.content &&
                        msg.content.address &&
                        ref.isAddress(msg.content.address)), pull.drain((msg) => {
                        this.ssb.gossip.add(msg.content.address, 'pub');
                    }, (...args) => {
                        console.warn('[gossip] warning: this can happen if the database closes', args);
                    }));
                }
            }
            for (let [address, data] of this.conn.dbPeers()) {
                if (data.source === 'dht') {
                    this.ssb.gossip.add(address, 'dht');
                }
                else if (data.source !== 'local' && data.source !== 'bt') {
                    this.ssb.gossip.add(address, 'stored');
                }
            }
        };
        this.stop = () => {
            this.hub.reset();
            this.closed = true;
        };
        this.ssb = ssb;
        this.config = config;
        this.conn = this.ssb.conn;
        this.hub = this.ssb.conn.internalConnHub();
        this.closed = true;
        this.lastMessageAt = 0;
        this.hasScheduledAnUpdate = false;
        this.ssb.post((msg) => {
            if (msg.value.author != this.ssb.id) {
                this.lastMessageAt = Date.now();
            }
        });
    }
    conf(name, def) {
        if (this.config.gossip == null)
            return def;
        const value = this.config.gossip[name];
        return value == null || value === '' ? def : value;
    }
    isCurrentlyDownloading() {
        return this.lastMessageAt && this.lastMessageAt > Date.now() - 500;
    }
    updateTheseConnections(test, opts) {
        const query = this.conn.query();
        const peersUp = query.peersInConnection().filter(test);
        const peersDown = query.peersConnectable('dbAndStaging').filter(test);
        const { quota, backoffStep, backoffMax, groupMin } = opts;
        const excess = peersUp.length > quota * 2 ? peersUp.length - quota : 0;
        const freeSlots = Math.max(quota - peersUp.length, 0);
        peersUp
            .filter(notBluetooth)
            .z(sortByStateChange)
            .z(take(excess))
            .forEach(([addr]) => this.hub.disconnect(addr).then(noop, noop));
        peersDown
            .filter(notBluetooth)
            .filter(canBeConnected)
            .z(passesGroupDebounce(groupMin))
            .filter(passesExpBackoff(backoffStep, backoffMax))
            .z(sortByStateChange)
            .z(take(freeSlots))
            .forEach(([addr, peer]) => this.hub.connect(addr, peer).then(noop, noop));
    }
    updateConnectionsNow() {
        if (!this.ssb.ready() || this.isCurrentlyDownloading())
            return;
        const numOfConnectedRemoteNonFriends = this.conn
            .query()
            .peersInConnection()
            .filter(and(not(isLocal), not(isFriend))).length;
        const numOfConnectedFriends = this.conn
            .query()
            .peersInConnection()
            .filter(isFriend).length;
        if (this.conf('friends', true))
            this.updateTheseConnections(isFriend, {
                quota: 3,
                backoffStep: 2e3,
                backoffMax: 10 * minute,
                groupMin: 1e3,
            });
        if (this.conf('seed', true))
            this.updateTheseConnections(p => p[1].source === 'seed', {
                quota: 3,
                backoffStep: 2e3,
                backoffMax: 10 * minute,
                groupMin: 1e3,
            });
        if (this.conf('local', true))
            this.updateTheseConnections(isLocal, {
                quota: 3,
                backoffStep: 2e3,
                backoffMax: 10 * minute,
                groupMin: 1e3,
            });
        if (this.conf('global', true)) {
            this.updateTheseConnections(and(isFriend, hasPinged), {
                quota: 2,
                backoffStep: 10e3,
                backoffMax: 10 * minute,
                groupMin: 5e3,
            });
            if (numOfConnectedFriends < 2) {
                this.updateTheseConnections(and(isFriend, hasNoAttempts), {
                    quota: 1,
                    backoffStep: 0,
                    backoffMax: 0,
                    groupMin: 0,
                });
            }
            this.updateTheseConnections(and(isFriend, hasOnlyFailedAttempts), {
                quota: 3,
                backoffStep: minute,
                backoffMax: 3 * hour,
                groupMin: 5 * minute,
            });
            this.updateTheseConnections(and(hasPinged, not(isFriend), not(isLocal)), {
                quota: 2,
                backoffStep: 10e3,
                backoffMax: 10 * minute,
                groupMin: 5e3,
            });
            if (numOfConnectedRemoteNonFriends === 0) {
                this.updateTheseConnections(hasNoAttempts, {
                    quota: 1,
                    backoffStep: 0,
                    backoffMax: 0,
                    groupMin: 0,
                });
            }
            this.updateTheseConnections(hasOnlyFailedAttempts, {
                quota: 3,
                backoffStep: 5 * minute,
                backoffMax: 3 * hour,
                groupMin: 5 * 50e3,
            });
            const longterm = this.conn
                .query()
                .peersInConnection()
                .filter(hasPinged).length;
            this.updateTheseConnections(isLegacy, {
                quota: 3 - longterm,
                backoffStep: 5 * minute,
                backoffMax: 3 * hour,
                groupMin: 5 * minute,
            });
        }
        this.conn
            .query()
            .peersInConnection()
            .filter(peer => {
            const permanent = hasPinged(peer) || isLocal(peer);
            return !permanent || this.hub.getState(peer[0]) === 'connecting';
        })
            .filter(peer => peer[1].stateChange + 10e3 < Date.now())
            .forEach(([addr]) => this.hub.disconnect(addr).then(noop, noop));
    }
    updateConnectionsSoon() {
        if (this.closed)
            return;
        if (this.hasScheduledAnUpdate)
            return;
        this.hasScheduledAnUpdate = true;
        const timer = setTimeout(() => {
            this.updateConnectionsNow();
            this.hasScheduledAnUpdate = false;
        }, 1000 * Math.random());
        if (timer.unref)
            timer.unref();
    }
};
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], ConnScheduler.prototype, "start", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], ConnScheduler.prototype, "stop", void 0);
ConnScheduler = __decorate([
    secret_stack_decorators_1.plugin('1.0.0')
], ConnScheduler);
exports.ConnScheduler = ConnScheduler;
