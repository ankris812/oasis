"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function modeToSource(mode) {
    if (mode === 'lan')
        return 'local';
    if (mode === 'bt')
        return 'bt';
    if (mode === 'internet')
        return 'pub';
    return 'manual';
}
class ConnQuery {
    constructor(db, hub, staging) {
        this.db = db;
        this.hub = hub;
        this.staging = staging;
    }
    _hubEntryToPeer([address, hubData]) {
        const peer = this.db.has(address)
            ? Object.assign({ address }, this.db.get(address)) : { address, source: 'manual' };
        if (hubData.key)
            peer.key = hubData.key;
        return peer;
    }
    peersConnected() {
        return Array.from(this.hub.entries())
            .filter(([_address, data]) => data.state === 'connected')
            .map((e) => this._hubEntryToPeer(e));
    }
    peersConnecting() {
        return Array.from(this.hub.entries())
            .filter(([_address, data]) => data.state === 'connecting')
            .map((e) => this._hubEntryToPeer(e));
    }
    peersInConnection() {
        return Array.from(this.hub.entries())
            .filter(([_address, data]) => data.state === 'connected' || data.state === 'connecting')
            .map((e) => this._hubEntryToPeer(e));
    }
    peersConnectable(pool = 'db') {
        const useDB = pool === 'db' || pool === 'dbAndStaging';
        const useStaging = pool === 'staging' || pool === 'dbAndStaging';
        return []
            .concat(useDB ? Array.from(this.db.entries()) : [])
            .concat(useStaging ? Array.from(this.staging.entries()) : [])
            .filter(([address]) => {
            const state = this.hub.getState(address);
            return state !== 'connected' && state !== 'connecting';
        })
            .map(([address, data]) => {
            if (!data.source && data.mode) {
                return Object.assign({ address, source: modeToSource(data.mode) }, data);
            }
            else {
                return Object.assign({ address }, data);
            }
        });
    }
    peersAll() {
        return this.peersConnectable().concat(this.peersInConnection());
    }
    static passesExpBackoff(step, max, timestamp = Date.now()) {
        return (peer) => {
            const prevAttempt = peer.stateChange | 0;
            const F = peer.failure | 0;
            const Q = step;
            const M = max;
            const expBackoff = Math.min(Math.pow(2, F) * Q, M || Infinity);
            const nextAttempt = prevAttempt + expBackoff;
            return nextAttempt < timestamp;
        };
    }
    static passesGroupDebounce(groupMin, timestamp = Date.now()) {
        return (group) => {
            const newestStateChange = group.reduce((M, p) => Math.max(M, p.stateChange || 0), 0);
            const minTimeThreshold = newestStateChange + groupMin;
            if (timestamp < minTimeThreshold)
                return [];
            else
                return group;
        };
    }
    static hasNoAttempts(p) {
        return !p.stateChange;
    }
    static hasOnlyFailedAttempts(p) {
        return !!p.stateChange && (!p.duration || p.duration.mean == 0);
    }
    static hasSuccessfulAttempts(p) {
        return !!p.duration && p.duration.mean > 0;
    }
    static hasPinged(p) {
        return !!p.ping && !!p.ping.rtt && p.ping.rtt.mean > 0;
    }
    static sortByStateChange(peers) {
        return peers.sort((a, b) => a.stateChange - b.stateChange);
    }
}
exports.ConnQuery = ConnQuery;
