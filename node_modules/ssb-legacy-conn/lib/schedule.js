"use strict";
const pull = require('pull-stream');
const ip = require('ip');
const onWakeup = require('on-wakeup');
const onNetwork = require('on-change-network');
const hasNetwork = require('./has-network-debounced');
function not(fn) {
    return function (e) {
        return !fn(e);
    };
}
function and(...args) {
    return function (value) {
        return args.every(function (fn) {
            return fn.call(null, value);
        });
    };
}
function delay(failures, factor, max) {
    return Math.min(Math.pow(2, failures) * factor, max || Infinity);
}
function maxStateChange(M, peer) {
    return Math.max(M, peer.stateChange || 0);
}
function peerNext(peer, opts) {
    return ((peer.stateChange | 0) + delay(peer.failure | 0, opts.factor, opts.max));
}
function isOffline(p) {
    if (ip.isLoopback(p.host) || p.host == 'localhost')
        return false;
    else if (p.source === 'bt')
        return false;
    else
        return !hasNetwork();
}
var isOnline = not(isOffline);
function isLocal(p) {
    return !ip.isLoopback(p.host) && ip.isPrivate(p.host) && p.source === 'local';
}
function isSeed(p) {
    return p.source === 'seed';
}
function isFriend(p) {
    return p.source === 'friends';
}
function isUnattempted(p) {
    return !p.stateChange;
}
function isInactive(p) {
    return p.stateChange && (!p.duration || p.duration.mean == 0);
}
function isLongterm(p) {
    return p.ping && p.ping.rtt && p.ping.rtt.mean > 0;
}
function isLegacy(peer) {
    return (peer.duration &&
        (peer.duration && peer.duration.mean > 0) &&
        !isLongterm(peer));
}
function makeIsConnect(connHub) {
    return function isConnect(p) {
        const state = connHub.getState(p.address);
        return state === 'connected' || state === 'connecting';
    };
}
function earliest(peers, n) {
    return peers
        .sort((a, b) => a.stateChange - b.stateChange)
        .slice(0, Math.max(n, 0));
}
function makeSelect(connHub) {
    const isConnect = makeIsConnect(connHub);
    return function select(peers, ts, filter, opts) {
        if (opts.disable)
            return [];
        var type = peers.filter(filter);
        var unconnect = type.filter(not(isConnect));
        var count = Math.max(opts.quota - type.filter(isConnect).length, 0);
        var min = unconnect.reduce(maxStateChange, 0) + opts.groupMin;
        if (ts < min)
            return [];
        return earliest(unconnect.filter(peer => peerNext(peer, opts) < ts), count);
    };
}
function convertModeToLegacySource(mode) {
    if (mode === 'lan')
        return 'local';
    if (mode === 'bt')
        return 'bt';
    if (mode === 'internet')
        return 'pub';
    return 'stored';
}
module.exports = function Schedule(config, server, connDB, connHub, connStaging) {
    const min = 60e3;
    const hour = 60 * 60e3;
    let closed = false;
    onWakeup(() => connHub.reset());
    onNetwork(() => connHub.reset());
    function conf(name, def) {
        if (config.gossip == null)
            return def;
        var value = config.gossip[name];
        return value == null || value === '' ? def : value;
    }
    const select = makeSelect(connHub);
    const isConnect = makeIsConnect(connHub);
    function connect(peers, ts, name, filter, opts) {
        opts.group = name;
        const connected = peers.filter(isConnect).filter(filter);
        if (connected.length > opts.quota * 2) {
            return earliest(connected, connected.length - opts.quota).forEach(peer => {
                connHub.disconnect(peer.address).then(() => { }, _err => { });
            });
        }
        const selected = select(peers, ts, and(filter, isOnline), opts);
        selected.forEach(peer => {
            connHub.connect(peer.address).then(() => { }, _err => { });
        });
    }
    var lastMessageAt;
    server.post(function (data) {
        if (data.value.author != server.id)
            lastMessageAt = Date.now();
    });
    function isCurrentlyDownloading() {
        return lastMessageAt && lastMessageAt > Date.now() - 500;
    }
    var connecting = false;
    function connections() {
        if (connecting || closed)
            return;
        connecting = true;
        var timer = setTimeout(function () {
            connecting = false;
            if (!server.ready() || isCurrentlyDownloading())
                return;
            const ts = Date.now();
            const peers = []
                .concat(Array.from(connDB.entries()).map(([address, data]) => (Object.assign({}, data, { address }))))
                .concat(Array.from(connStaging.entries()).map(([address, data]) => (Object.assign({}, data, { address, source: convertModeToLegacySource(data.mode) }))));
            const connected = peers.filter(and(isConnect, not(isLocal), not(isFriend))).length;
            const connectedFriends = peers.filter(and(isConnect, isFriend)).length;
            if (conf('friends', true))
                connect(peers, ts, 'friends', isFriend, {
                    quota: 3,
                    factor: 2e3,
                    max: 10 * min,
                    groupMin: 1e3,
                });
            if (conf('seed', true))
                connect(peers, ts, 'seeds', isSeed, {
                    quota: 3,
                    factor: 2e3,
                    max: 10 * min,
                    groupMin: 1e3,
                });
            if (conf('local', true))
                connect(peers, ts, 'local', isLocal, {
                    quota: 3,
                    factor: 2e3,
                    max: 10 * min,
                    groupMin: 1e3,
                });
            if (conf('global', true)) {
                connect(peers, ts, 'friends', and(isFriend, isLongterm), {
                    quota: 2,
                    factor: 10e3,
                    max: 10 * min,
                    groupMin: 5e3,
                });
                if (connectedFriends < 2)
                    connect(peers, ts, 'attemptFriend', and(isFriend, isUnattempted), {
                        min: 0,
                        quota: 1,
                        factor: 0,
                        max: 0,
                        groupMin: 0,
                    });
                connect(peers, ts, 'retryFriends', and(isFriend, isInactive), {
                    min: 0,
                    quota: 3,
                    factor: 60e3,
                    max: 3 * 60 * 60e3,
                    groupMin: 5 * 60e3,
                });
                connect(peers, ts, 'longterm', and(isLongterm, not(isFriend), not(isLocal)), {
                    quota: 2,
                    factor: 10e3,
                    max: 10 * min,
                    groupMin: 5e3,
                });
                if (!connected)
                    connect(peers, ts, 'attempt', isUnattempted, {
                        min: 0,
                        quota: 1,
                        factor: 0,
                        max: 0,
                        groupMin: 0,
                    });
                connect(peers, ts, 'retry', isInactive, {
                    min: 0,
                    quota: 3,
                    factor: 5 * 60e3,
                    max: 3 * 60 * 60e3,
                    groupMin: 5 * 50e3,
                });
                var longterm = peers.filter(isConnect).filter(isLongterm).length;
                connect(peers, ts, 'legacy', isLegacy, {
                    quota: 3 - longterm,
                    factor: 5 * min,
                    max: 3 * hour,
                    groupMin: 5 * min,
                });
            }
            peers.filter(isConnect).forEach(p => {
                const permanent = isLongterm(p) || isLocal(p);
                if ((!permanent || connHub.getState(p.address) === 'connecting') &&
                    p.stateChange + 10e3 < ts) {
                    connHub.disconnect(p.address);
                }
            });
        }, 1000 * Math.random());
        if (timer.unref)
            timer.unref();
    }
    pull(connHub.listen(), pull.drain((ev) => {
        if (ev.type == 'disconnected')
            connections();
    }, function () {
        console.warn('[gossip/dc] warning: this can happen if the database closes', arguments);
    }));
    var int = setInterval(connections, 2e3);
    if (int.unref)
        int.unref();
    connections();
    return function onClose() {
        closed = true;
    };
};
