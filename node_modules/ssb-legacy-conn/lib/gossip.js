"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const secret_stack_decorators_1 = require("secret-stack-decorators");
const pull = require('pull-stream');
const Notify = require('pull-notify');
const ref = require('ssb-ref');
const fs = require('fs');
const path = require('path');
function isPeerObject(o) {
    return o && 'object' == typeof o;
}
function toBase64(s) {
    if (typeof s === 'string')
        return s.substring(1, s.indexOf('.'));
    else
        return s.toString('base64');
}
function toAddressString(address) {
    if (isPeerObject(address)) {
        if (ref.isAddress(address.address))
            return address.address;
        if (address.source === 'dht') {
            return (['dht', address.host].join(':') + '~' + 'noauth');
        }
        else if (address.source === 'bt') {
            return (['bt', address.host].join(':') +
                '~' +
                ['shs', toBase64(address.key)].join(':'));
        }
        let protocol = 'net';
        if (address.host && address.host.endsWith('.onion'))
            protocol = 'onion';
        return ([protocol, address.host, address.port].join(':') +
            '~' +
            ['shs', toBase64(address.key)].join(':'));
    }
    return address;
}
function isDhtAddress(addr) {
    return typeof addr === 'string' && addr.substr(0, 4) === 'dht:';
}
function parseDhtAddress(addr) {
    const [transport] = addr.split('~');
    const [dhtTag, seed, remoteId] = transport.split(':');
    if (dhtTag !== 'dht')
        throw new Error('Invalid DHT address ' + addr);
    return {
        host: seed + ':' + remoteId,
        port: 0,
        key: remoteId[0] === '@' ? remoteId : '@' + remoteId,
        source: 'dht',
    };
}
function parseAddress(address) {
    if (isDhtAddress(address)) {
        return parseDhtAddress(address);
    }
    const legacyParsing = ref.parseAddress(address);
    if (legacyParsing) {
        return legacyParsing;
    }
    else if (ref.isAddress(address)) {
        return { key: ref.getKeyFromAddress(address) };
    }
}
function simplifyPeerForStatus(peer) {
    return {
        address: peer.address || toAddressString(peer),
        source: peer.source,
        state: peer.state,
        stateChange: peer.stateChange,
        failure: peer.failure,
        client: peer.client,
        stats: {
            duration: peer.duration || undefined,
            rtt: peer.ping ? peer.ping.rtt : undefined,
            skew: peer.ping ? peer.ping.skew : undefined,
        },
    };
}
function validateAddr(addr) {
    if (!addr || (typeof addr !== 'object' && typeof addr !== 'string')) {
        throw new Error('address should be an object or string');
    }
    const addressString = typeof addr === 'string' ? addr : toAddressString(addr);
    const parsed = typeof addr === 'object' ? addr : parseAddress(addressString);
    if (!parsed.key)
        throw new Error('address must have ed25519 key');
    if (!ref.isFeed(parsed.key))
        throw new Error('key must be ed25519 public id');
    return [addressString, parsed];
}
function inferSource(address) {
    return address.startsWith('net:')
        ? 'local'
        : address.startsWith('bt:')
            ? 'bt'
            : 'manual';
}
let Gossip = class Gossip {
    constructor(ssb, cfg) {
        this.peers = () => {
            const peers = Array.from(this.connDB.entries()).map(([address, data]) => {
                return Object.assign({}, data, { address, state: this.connHub.getState(address) });
            });
            for (const [address, data] of this.connHub.entries()) {
                if (!this.connDB.has(address)) {
                    const [, parsed] = validateAddr(address);
                    peers.push(Object.assign({}, data, parsed, { address, source: inferSource(address) }));
                }
            }
            return peers;
        };
        this.get = (addr) => {
            if (ref.isFeed(addr)) {
                for (let [address, data] of this.connDB.entries()) {
                    if (data.key === addr) {
                        return Object.assign({}, data, { address });
                    }
                }
                return undefined;
            }
            const [addressString] = validateAddr(addr);
            const peer = this.connDB.get(addressString);
            if (!peer)
                return undefined;
            else {
                return Object.assign({ address: addressString, state: this.connHub.getState(addressString) }, peer);
            }
        };
        this.connect = (addr, cb) => {
            let addressString;
            try {
                const inputAddr = ref.isFeed(addr) ? this.idToAddr(addr) : addr;
                [addressString] = validateAddr(inputAddr);
            }
            catch (err) {
                return cb(err);
            }
            this.add(addressString, 'manual');
            this.ssb.conn.connect(addressString, cb);
        };
        this.disconnect = (addr, cb) => {
            let addressString;
            try {
                const inputAddr = ref.isFeed(addr) ? this.idToAddr(addr) : addr;
                [addressString] = validateAddr(inputAddr);
            }
            catch (err) {
                return cb(err);
            }
            this.ssb.conn.disconnect(addressString, cb);
        };
        this.changes = () => {
            return this.notify.listen();
        };
        this.add = (addr, source) => {
            const [addressString, parsed] = validateAddr(addr);
            if (parsed.key === this.ssb.id)
                return;
            if (source === 'local') {
                this.connStaging.stage(addressString, {
                    type: 'lan',
                    host: parsed.host,
                    port: parsed.port,
                    key: parsed.key,
                    address: addressString,
                    announcers: 1,
                    duration: 0,
                });
                this.notify({
                    type: 'discover',
                    peer: Object.assign({}, parsed, { state: this.connHub.getState(addressString), source: source || 'manual' }),
                    source: source || 'manual',
                });
                return parsed;
            }
            const existingPeer = this.connDB.get(addressString);
            if (!existingPeer) {
                this.connDB.set(addressString, {
                    host: parsed.host,
                    port: parsed.port,
                    key: parsed.key,
                    address: addressString,
                    source: source,
                    announcers: 1,
                });
                this.notify({
                    type: 'discover',
                    peer: Object.assign({}, parsed, { state: this.connHub.getState(addressString), source: source || 'manual' }),
                    source: source || 'manual',
                });
                return this.connDB.get(addressString) || parsed;
            }
            else {
                if (source === 'friends') {
                    this.connDB.update(addressString, { source });
                }
                else {
                    this.connDB.update(addressString, (prev) => ({
                        announcers: prev.announcers + 1,
                    }));
                }
                return this.connDB.get(addressString);
            }
        };
        this.remove = (addr) => {
            const [addressString] = validateAddr(addr);
            this.connHub.disconnect(addressString);
            this.connStaging.unstage(addressString);
            const peer = this.connDB.get(addressString);
            if (!peer)
                return;
            this.connDB.delete(addressString);
            this.notify({ type: 'remove', peer: peer });
        };
        this.ping = () => this.ssb.conn.ping();
        this.reconnect = () => {
            this.connHub.reset();
            return (this.wakeup = Date.now());
        };
        this.enable = (type) => {
            if (!!type && typeof type !== 'string') {
                throw new Error('enable() expects an optional string as argument');
            }
            const actualType = type || 'global';
            this.setConfig(actualType, true);
            if (actualType === 'local' && this.ssb.local && this.ssb.local.init) {
                this.ssb.local.init();
            }
            return 'enabled gossip type ' + actualType;
        };
        this.disable = (type) => {
            if (!!type && typeof type !== 'string') {
                throw new Error('disable() expects an optional string as argument');
            }
            const actualType = type || 'global';
            this.setConfig(actualType, false);
            return 'disabled gossip type ' + actualType;
        };
        this.ssb = ssb;
        this.config = cfg;
        this.wakeup = 0;
        this.status = {};
        this.notify = Notify();
        this.connDB = this.ssb.conn.internalConnDB();
        this.connHub = this.ssb.conn.internalConnHub();
        this.connStaging = this.ssb.conn.internalConnStaging();
        this.setupStatusHook();
        this.setupConnectionListeners();
        this.ssb.conn.start();
    }
    setupStatusHook() {
        const connDB = this.connDB;
        const connHub = this.connHub;
        const status = this.status;
        this.ssb.status.hook(function (fn) {
            const _status = fn();
            _status.gossip = status;
            for (let [address, data] of connDB.entries()) {
                const state = connHub.getState(address);
                if (state === 'connected' || data.stateChange + 3e3 > Date.now()) {
                    if (data.key) {
                        status[data.key] = simplifyPeerForStatus(Object.assign({}, data, { state }));
                    }
                }
            }
            return _status;
        });
    }
    setupConnectionListeners() {
        pull(this.connHub.listen(), pull.drain((ev) => {
            if (ev.type === 'connecting')
                this.onConnecting(ev);
            if (ev.type === 'connecting-failed')
                this.onConnectingFailed(ev);
            if (ev.type === 'connected')
                this.onConnected(ev);
            if (ev.type === 'disconnecting')
                this.onDisconnecting(ev);
            if (ev.type === 'disconnecting-failed')
                this.onDisconnectingFailed(ev);
            if (ev.type === 'disconnected')
                this.onDisconnected(ev);
        }));
    }
    setConfig(name, value) {
        this.config.gossip = this.config.gossip || {};
        this.config.gossip[name] = value;
        const cfgPath = path.join(this.config.path, 'config');
        let configInFS = {};
        try {
            configInFS = JSON.parse(fs.readFileSync(cfgPath, 'utf-8'));
        }
        catch (e) { }
        configInFS.gossip = configInFS.gossip || {};
        configInFS.gossip[name] = value;
        fs.writeFileSync(cfgPath, JSON.stringify(configInFS, null, 2), 'utf-8');
    }
    onConnecting(ev) {
        this.ssb.emit('log:info', ['ssb-server', ev.address, 'CONNECTING']);
    }
    onConnectingFailed(ev) {
        const peer = Object.assign({ state: ev.type, address: ev.address, key: ev.key }, this.connDB.get(ev.address));
        this.notify({ type: 'connect-failure', peer });
        const err = (ev.details && ev.details.message) || ev.details;
        this.ssb.emit('log:info', ['ssb-server', ev.address, 'ERR', err]);
    }
    onConnected(ev) {
        const peer = Object.assign({ state: ev.type, address: ev.address, key: ev.key }, this.connDB.get(ev.address));
        if (!this.connDB.has(ev.address))
            peer.source = inferSource(ev.address);
        if (ev.key) {
            this.status[ev.key] = simplifyPeerForStatus(peer);
        }
        this.ssb.emit('log:info', ['ssb-server', ev.address, 'PEER JOINED']);
        this.notify({ type: 'connect', peer });
    }
    onDisconnecting(_ev) {
    }
    onDisconnectingFailed(_ev) {
    }
    onDisconnected(ev) {
        const peer = Object.assign({ state: ev.type, address: ev.address, key: ev.key }, this.connDB.get(ev.address));
        if (ev.key) {
            delete this.status[ev.key];
        }
        this.ssb.emit('log:info', [
            'ssb-server',
            ev.address,
            [
                'DISCONNECTED. state was',
                peer.state,
                'for',
                (Date.now() - peer.stateChange) / 1000,
                'seconds',
            ].join(' '),
        ]);
        this.notify({ type: 'disconnect', peer });
    }
    idToAddr(id) {
        const addr = this.connDB.getAddressForId(id);
        if (!addr) {
            throw new Error('no known address for peer:' + id);
        }
        return addr;
    }
};
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "peers", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "get", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async')
], Gossip.prototype, "connect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async')
], Gossip.prototype, "disconnect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], Gossip.prototype, "changes", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "add", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "remove", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('duplex', { anonymous: 'allow' })
], Gossip.prototype, "ping", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "reconnect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "enable", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], Gossip.prototype, "disable", void 0);
Gossip = __decorate([
    secret_stack_decorators_1.plugin('1.0.0')
], Gossip);
exports.Gossip = Gossip;
