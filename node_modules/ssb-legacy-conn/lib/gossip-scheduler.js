"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ConnQuery = require("ssb-conn-query");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const pull = require('pull-stream');
const ip = require('ip');
const onWakeup = require('on-wakeup');
const onNetwork = require('on-change-network');
const hasNetwork = require('./has-network-debounced');
const ref = require('ssb-ref');
require('zii');
function noop() { }
function not(fn) {
    return function (e) {
        return !fn(e);
    };
}
function and(...args) {
    return (value) => args.every((fn) => fn.call(null, value));
}
function isOffline(p) {
    if (ip.isLoopback(p.host) || p.host == 'localhost')
        return false;
    else if (p.source === 'bt')
        return false;
    else
        return !hasNetwork();
}
const canBeConnected = not(isOffline);
function isLocal(p) {
    return !ip.isLoopback(p.host) && ip.isPrivate(p.host) && p.source === 'local';
}
function isLegacy(peer) {
    return hasSuccessfulAttempts(peer) && !hasPinged(peer);
}
function isFriend(p) {
    return p.source === 'friends';
}
function take(n) {
    return (arr) => arr.slice(0, Math.max(n, 0));
}
const { passesExpBackoff, passesGroupDebounce, hasNoAttempts, hasOnlyFailedAttempts, hasPinged, hasSuccessfulAttempts, sortByStateChange, } = ConnQuery;
const minute = 60e3;
const hour = 60 * 60e3;
let GossipScheduler = class GossipScheduler {
    constructor(ssb, config) {
        this.start = () => {
            onWakeup(() => this.hub.reset());
            onNetwork(() => this.hub.reset());
            pull(this.hub.listen(), pull.filter((ev) => ev.type === 'disconnected'), pull.drain(() => this.updateConnectionsSoon(), (...args) => console.warn('[gossip/dc] warning: this can happen if the database closes', args)));
            const int = setInterval(() => this.updateConnectionsSoon(), 2e3);
            if (int.unref)
                int.unref();
            this.updateConnectionsSoon();
            if (this.config.offline) {
                console.log('Running in offline mode: gossip disabled');
            }
            else {
                const seeds = this.config.seeds;
                (Array.isArray(seeds) ? seeds : [seeds]).filter(Boolean).forEach(addr => {
                    this.ssb.gossip.add(addr, 'seed');
                });
                if (!this.config.gossip ||
                    (this.config.gossip.autoPopulate !== false &&
                        this.config.gossip.pub !== false)) {
                    pull(this.ssb.messagesByType({ type: 'pub', live: true, keys: false }), pull.filter((msg) => !msg.sync), pull.filter((msg) => msg.content &&
                        msg.content.address &&
                        ref.isAddress(msg.content.address)), pull.drain((msg) => {
                        this.ssb.gossip.add(msg.content.address, 'pub');
                    }, (...args) => {
                        console.warn('[gossip] warning: this can happen if the database closes', args);
                    }));
                }
            }
            for (let [address, data] of this.db.entries()) {
                if (data.source === 'dht') {
                    this.ssb.gossip.add(address, 'dht');
                }
                else if (data.source !== 'local' && data.source !== 'bt') {
                    this.ssb.gossip.add(address, 'stored');
                }
            }
        };
        this.stop = () => {
            this.closed = true;
        };
        this.ssb = ssb;
        this.config = config;
        this.db = this.ssb.gossip.db();
        this.hub = this.ssb.gossip.hub();
        this.query = this.ssb.gossip.query();
        this.closed = false;
        this.lastMessageAt = 0;
        this.hasScheduledAnUpdate = false;
        this.ssb.post((data) => {
            if (data.value.author != this.ssb.id) {
                this.lastMessageAt = Date.now();
            }
        });
    }
    conf(name, def) {
        if (this.config.gossip == null)
            return def;
        const value = this.config.gossip[name];
        return value == null || value === '' ? def : value;
    }
    isCurrentlyDownloading() {
        return this.lastMessageAt && this.lastMessageAt > Date.now() - 500;
    }
    updateTheseConnections(test, opts) {
        const peersUp = this.query.peersInConnection().filter(test);
        const peersDown = this.query.peersConnectable('dbAndStaging').filter(test);
        const { quota, backoffStep, backoffMax, groupMin } = opts;
        const excess = peersUp.length > quota * 2 ? peersUp.length - quota : 0;
        const freeSlots = Math.max(quota - peersUp.length, 0);
        peersUp
            .z(sortByStateChange)
            .z(take(excess))
            .forEach(peer => this.hub.disconnect(peer.address).then(noop, noop));
        peersDown
            .filter(canBeConnected)
            .z(passesGroupDebounce(groupMin))
            .filter(passesExpBackoff(backoffStep, backoffMax))
            .z(sortByStateChange)
            .z(take(freeSlots))
            .forEach(peer => this.hub.connect(peer.address).then(noop, noop));
    }
    updateConnectionsNow() {
        if (!this.ssb.ready() || this.isCurrentlyDownloading())
            return;
        const numOfConnectedRemoteNonFriends = this.query
            .peersInConnection()
            .filter(and(not(isLocal), not(isFriend))).length;
        const numOfConnectedFriends = this.query
            .peersInConnection()
            .filter(isFriend).length;
        if (this.conf('friends', true))
            this.updateTheseConnections(isFriend, {
                quota: 3,
                backoffStep: 2e3,
                backoffMax: 10 * minute,
                groupMin: 1e3,
            });
        if (this.conf('seed', true))
            this.updateTheseConnections(p => p.source === 'seed', {
                quota: 3,
                backoffStep: 2e3,
                backoffMax: 10 * minute,
                groupMin: 1e3,
            });
        if (this.conf('local', true))
            this.updateTheseConnections(isLocal, {
                quota: 3,
                backoffStep: 2e3,
                backoffMax: 10 * minute,
                groupMin: 1e3,
            });
        if (this.conf('global', true)) {
            this.updateTheseConnections(and(isFriend, hasPinged), {
                quota: 2,
                backoffStep: 10e3,
                backoffMax: 10 * minute,
                groupMin: 5e3,
            });
            if (numOfConnectedFriends < 2) {
                this.updateTheseConnections(and(isFriend, hasNoAttempts), {
                    quota: 1,
                    backoffStep: 0,
                    backoffMax: 0,
                    groupMin: 0,
                });
            }
            this.updateTheseConnections(and(isFriend, hasOnlyFailedAttempts), {
                quota: 3,
                backoffStep: minute,
                backoffMax: 3 * hour,
                groupMin: 5 * minute,
            });
            this.updateTheseConnections(and(hasPinged, not(isFriend), not(isLocal)), {
                quota: 2,
                backoffStep: 10e3,
                backoffMax: 10 * minute,
                groupMin: 5e3,
            });
            if (numOfConnectedRemoteNonFriends === 0) {
                this.updateTheseConnections(hasNoAttempts, {
                    quota: 1,
                    backoffStep: 0,
                    backoffMax: 0,
                    groupMin: 0,
                });
            }
            this.updateTheseConnections(hasOnlyFailedAttempts, {
                quota: 3,
                backoffStep: 5 * minute,
                backoffMax: 3 * hour,
                groupMin: 5 * 50e3,
            });
            const longterm = this.query.peersInConnection().filter(hasPinged).length;
            this.updateTheseConnections(isLegacy, {
                quota: 3 - longterm,
                backoffStep: 5 * minute,
                backoffMax: 3 * hour,
                groupMin: 5 * minute,
            });
        }
        this.query
            .peersInConnection()
            .filter(p => {
            const permanent = hasPinged(p) || isLocal(p);
            return !permanent || this.hub.getState(p.address) === 'connecting';
        })
            .filter(p => p.stateChange + 10e3 < Date.now())
            .forEach(p => this.hub.disconnect(p.address).then(noop, noop));
    }
    updateConnectionsSoon() {
        if (this.closed)
            return;
        if (this.hasScheduledAnUpdate)
            return;
        this.hasScheduledAnUpdate = true;
        const timer = setTimeout(() => {
            this.updateConnectionsNow();
            this.hasScheduledAnUpdate = false;
        }, 1000 * Math.random());
        if (timer.unref)
            timer.unref();
    }
};
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], GossipScheduler.prototype, "start", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], GossipScheduler.prototype, "stop", void 0);
GossipScheduler = __decorate([
    secret_stack_decorators_1.plugin('1.0.0')
], GossipScheduler);
exports.GossipScheduler = GossipScheduler;
