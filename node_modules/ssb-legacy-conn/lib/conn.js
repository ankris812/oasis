"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ConnDB = require("ssb-conn-db");
const ConnHub = require("ssb-conn-hub");
const ConnStaging = require("ssb-conn-staging");
const ConnQuery = require("ssb-conn-query");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const pull = require('pull-stream');
const msAddress = require('multiserver-address');
const stats = require('statistics');
const ping = require('pull-ping');
let CONN = class CONN {
    constructor(ssb, cfg) {
        this.connect = (address, second, third) => {
            if (typeof second === 'function' && typeof third === 'function') {
                throw new Error('CONN.connect() received incorrect arguments');
            }
            const cb = (typeof third === 'function' ? third : second);
            const data = (typeof third === 'function' ? second : undefined);
            try {
                this.assertValidAddress(address);
            }
            catch (err) {
                cb(err);
                return;
            }
            this.connHub
                .connect(address, data)
                .then(result => cb && cb(null, result), err => cb && cb(err));
        };
        this.disconnect = (address, cb) => {
            try {
                this.assertValidAddress(address);
            }
            catch (err) {
                cb(err);
                return;
            }
            this.connHub
                .disconnect(address)
                .then(result => cb && cb(null, result), err => cb && cb(err));
        };
        this.stage = (address, data = { type: 'internet' }) => {
            return this.connStaging.stage(address, data);
        };
        this.unstage = (address) => {
            return this.connStaging.unstage(address);
        };
        this.remember = (address, data = {}) => {
            this.assertValidAddress(address);
            this.connDB.set(address, data);
        };
        this.forget = (address) => {
            this.assertValidAddress(address);
            this.connDB.delete(address);
        };
        this.peers = () => this.connHub.liveEntries();
        this.stagedPeers = () => this.connStaging.liveEntries();
        this.start = () => {
            return this.startScheduler();
        };
        this.stop = () => {
            this.stopScheduler();
        };
        this.ping = () => {
            const MIN = 10e3;
            const DEFAULT = 5 * 60e3;
            const MAX = 30 * 60e3;
            let timeout = (this.config.timers && this.config.timers.ping) || DEFAULT;
            timeout = Math.max(MIN, Math.min(timeout, MAX));
            return ping({ timeout });
        };
        this.internalConnDb = () => this.connDB;
        this.internalConnHub = () => this.connHub;
        this.internalConnStaging = () => this.connStaging;
        this.internalConnQuery = () => this.connQuery;
        this.ssb = ssb;
        this.config = cfg;
        this.connDB = new ConnDB({ path: this.config.path, writeTimeout: 10e3 });
        this.connHub = new ConnHub(this.ssb);
        this.connStaging = new ConnStaging(this.connHub);
        this.connQuery = new ConnQuery(this.connDB, this.connHub, this.connStaging);
        this.initialize();
    }
    initialize() {
        this.setupCloseHook();
        this.setupConnectionListeners();
        this.maybeAutoStartScheduler();
    }
    setupCloseHook() {
        const that = this;
        this.ssb.close.hook(function (fn, args) {
            that.stopScheduler();
            that.connDB.close();
            that.connHub.close();
            that.connStaging.close();
            return fn.apply(this, args);
        });
    }
    maybeAutoStartScheduler() {
        if (this.config.conn && this.config.conn.autostart !== false) {
            this.startScheduler();
        }
    }
    setupConnectionListeners() {
        pull(this.connHub.listen(), pull.drain((ev) => {
            if (ev.type === 'connecting')
                this.onConnecting(ev);
            if (ev.type === 'connecting-failed')
                this.onConnectingFailed(ev);
            if (ev.type === 'connected')
                this.onConnected(ev);
            if (ev.type === 'disconnecting')
                this.onDisconnecting(ev);
            if (ev.type === 'disconnecting-failed')
                this.onDisconnectingFailed(ev);
            if (ev.type === 'disconnected')
                this.onDisconnected(ev);
        }));
    }
    onConnecting(ev) {
        this.connDB.update(ev.address, { stateChange: Date.now() });
    }
    onConnectingFailed(ev) {
        this.connDB.update(ev.address, (prev) => ({
            failure: (prev.failure || 0) + 1,
            stateChange: Date.now(),
            duration: stats(prev.duration, 0),
        }));
    }
    onConnected(ev) {
        this.connDB.update(ev.address, { stateChange: Date.now(), failure: 0 });
        if (ev.details.isClient)
            this.setupPing(ev.address, ev.details.rpc);
    }
    onDisconnecting(ev) {
        this.connDB.update(ev.address, { stateChange: Date.now() });
    }
    onDisconnectingFailed(ev) {
        this.connDB.update(ev.address, { stateChange: Date.now() });
    }
    onDisconnected(ev) {
        this.connDB.update(ev.address, (prev) => ({
            stateChange: Date.now(),
            duration: stats(prev.duration, Date.now() - prev.stateChange),
        }));
    }
    startScheduler() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connDB.loaded();
            if (this.ssb.connScheduler) {
                this.ssb.connScheduler.start();
            }
            else {
                setTimeout(() => {
                    if (this.ssb.connScheduler) {
                        this.ssb.connScheduler.start();
                    }
                    else {
                        console.error('There is no ConnScheduler! ' +
                            'The CONN plugin will remain in manual mode.');
                    }
                }, 100);
            }
        });
    }
    stopScheduler() {
        if (this.ssb.connScheduler)
            this.ssb.connScheduler.stop();
    }
    setupPing(address, rpc) {
        const PING_TIMEOUT = 5 * 6e4;
        const pp = ping({ serve: true, timeout: PING_TIMEOUT }, () => { });
        this.connDB.update(address, { ping: { rtt: pp.rtt, skew: pp.skew } });
        pull(pp, rpc.gossip.ping({ timeout: PING_TIMEOUT }, (err) => {
            if (err && err.name === 'TypeError') {
                this.connDB.update(address, (prev) => ({
                    ping: Object.assign({}, (prev.ping || {}), { fail: true }),
                }));
            }
        }), pp);
    }
    assertValidAddress(address) {
        if (!msAddress.check(address)) {
            throw new Error('The given address is not a valid multiserver-address');
        }
    }
};
__decorate([
    secret_stack_decorators_1.muxrpc('async')
], CONN.prototype, "connect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('async')
], CONN.prototype, "disconnect", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "stage", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "unstage", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "remember", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "forget", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], CONN.prototype, "peers", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('source')
], CONN.prototype, "stagedPeers", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "start", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "stop", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('duplex', { anonymous: 'allow' })
], CONN.prototype, "ping", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "internalConnDb", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "internalConnHub", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "internalConnStaging", void 0);
__decorate([
    secret_stack_decorators_1.muxrpc('sync')
], CONN.prototype, "internalConnQuery", void 0);
CONN = __decorate([
    secret_stack_decorators_1.plugin('1.0.0')
], CONN);
exports.CONN = CONN;
