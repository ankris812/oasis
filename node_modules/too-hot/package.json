{
  "name": "too-hot",
  "version": "1.0.1",
  "description": "Answers whether your CPU is too busy",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@gitlab.com/staltz/too-hot.git"
  },
  "keywords": [
    "cpu-percentage"
  ],
  "author": "Andre Staltz <contact@staltz.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://gitlab.com/staltz/too-hot/issues"
  },
  "files": [
    "index.js",
    "LICENSE",
    "package.json",
    "readme.md"
  ],
  "dependencies": {
    "cpu-percentage": "~1.0.3"
  },
  "devDependencies": {
    "tape": "^4.9.0"
  },
  "scripts": {
    "test": "tape test.js"
  },
  "readme": "# too-hot\n\n> Answers whether your CPU is too busy\n\n```bash\nnpm install --save too-hot\n```\n\nSimilar to [pull-drain-gently](https://gitlab.com/staltz/pull-drain-gently), but for general purpose.\n\n## Usage\n\n### Default use\n\n```js\nconst TooHot = require('too-hot');\n\nasync function main() {\n  const tooHot = TooHot()\n  for (let i = 0; i < 10000; i++) {\n    someKindOfHeavyProcessing()\n    const hot = tooHot() // returns a Promise or `false`\n    if (hot) await hot\n  }\n}\n```\n\nFor `too-hot` to be effective and to make sense, you should only use this when iterating over a large chunk of data. Otherwise, the timers inside tooHot() will be too spaced apart and the CPU stats will lose precision.\n\n### Tweaking the parameters\n\nEvery once in a while, `tooHot()` will check the CPU usage, and if it has gone above the limit known as the `ceiling`, it returns a promise that (when `.then`d or `await`ened) will wait for `wait` milliseconds, in such a way that to keep CPU a bit under the chosen `ceiling` limit. In other words, two parameters control the behavior:\n\n- `ceiling`: the maximum CPU usage you want the Node.js process to consume, approximately, in percentages (`100` is 100%, not `1`)\n- `wait`: the waiting period, in milliseconds, when pausing in order to allow other tasks to use the CPU\n\nThe default CPU ceiling is `88%` and the default waiting period for each pause is `144ms` (roughly 9 frames if you have the UI running at 60fps). If the CPU remains hot even after the returned promise resolves, the next `tooHot()` will also return a promise to create another pause. This can keep on going indefinitely if the CPU remains hot.\n\nThere is also a third less common parameter, which by default is turned off:\n\n- `maxPause`: a limit in milliseconds for how long to pause (caused by consecutive promises returned). For instance, when `maxPause = 5000`, if the last time `tooHot()` returned `false` was 5 seconds ago, then it will necessarily return `false` this time, _regardless_ of the current CPU usage. **The default is `Infinity`**.\n\nTo configure your own parameters, pass an `opts` object as the argument to `gently`:\n\n```js\nconst TooHot = require('too-hot');\n\nasync function main() {\n  const tooHot = TooHot({ ceiling: 90, wait: 60 })\n  for (let i = 0; i < 10000; i++) {\n    someKindOfHeavyProcessing()\n    const hot = tooHot()\n    if (hot) await hot\n  }\n}\n```\n\nTo configure these parameters, consider that:\n\n- The **greater the `ceiling`** is, the closer your program behaves as if `too-hot` were not used, i.e. the **more hot** your CPU will run on heavy processing\n- The **smaller the `ceiling`** is, the **more time** it will take to complete the processing of data, i.e. the slower your application will finish its CPU tasks\n- The **greater the `wait`**, the **more fluctuation** of CPU usage will happen, both below and above the `ceiling`, i.e. the more bumpy the ride is for CPU usage and workload throughput\n- The **smaller the `wait`**, the more the actual CPU usage accurately meets the `ceiling`, but also the **more overhead** there is with many short-lived timers for those pauses\n\nThe total time for completing processing is important. Not using `too-hot` is the *fastest* in total time, but using `too-hot` with a small `wait` might give a total  time of approx. 2.5x slower than the fastest.\n\nThe defaults `ceiling=88`, `wait=144` are a sweet spot, and it can achieve a total time of approx 1.4x slower than the fastest.\n\nThe table below shows how the JS CPU flamechart looks like when running the benchmarks on Ubuntu 18.04.3 x86_64, Intel® Core™ i7-7500U CPU @ 2.70GHz × 4, 15,4 GiB RAM, for different values of the `ceiling` parameter. \"Unlimited\" means \"`too-hot` was not used\":\n\n| CPU `ceiling` | CPU Profiler in Chrome |\n|-----------|------------------------|\n| Unlimited | ![100](./images/100.png) |\n| `90`% | ![90](./images/90.png) |\n| `80`% | ![80](./images/80.png) |\n| `70`% | ![70](./images/70.png) |\n| `60`% | ![60](./images/60.png) |\n| `50`% | ![50](./images/50.png) |\n| `40`% | ![40](./images/40.png) |\n\n## License\n\n[MIT](https://tldrlegal.com/license/mit-license)\n"
}