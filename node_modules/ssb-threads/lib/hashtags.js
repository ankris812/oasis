"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bipf = require('bipf');
const pl = require('pull-level');
const pull = require('pull-stream');
const DB2Plugin = require('ssb-db2/indexes/plugin');
const { seqs, liveSeqs, deferred } = require('ssb-db2/operators');
const B_0 = Buffer.alloc(0);
const BIPF_CONTENT = bipf.allocAndEncode('content');
const BIPF_CHANNEL = bipf.allocAndEncode('channel');
const BIPF_MENTIONS = bipf.allocAndEncode('mentions');
function sanitize(hashtag) {
    return hashtag.startsWith('#')
        ? hashtag.slice(1).toLocaleLowerCase()
        : hashtag.toLocaleLowerCase();
}
const INDEX_NAME = 'hashtags';
const INDEX_VERSION = 2;
// [hashtagLabel, seq] => B_0
class HashtagPlugin extends DB2Plugin {
    constructor(log, dir) {
        super(log, dir, INDEX_NAME, INDEX_VERSION, 'json', 'binary');
    }
    static hasHashtagOperator(texts) {
        return deferred((meta, cb, onAbort) => {
            meta.db.onDrain(INDEX_NAME, () => {
                const plugin = meta.db.getIndex(INDEX_NAME);
                plugin.getMessagesByHashtags(texts, meta.live, cb, onAbort);
            });
        });
    }
    static hasSomeHashtagOperator() {
        return deferred((meta, cb, onAbort) => {
            meta.db.onDrain(INDEX_NAME, () => {
                const plugin = meta.db.getIndex(INDEX_NAME);
                plugin.getMessagesWithSomeHashtag(meta.live, cb, onAbort);
            });
        });
    }
    processRecord(record, seq, pValue) {
        const buf = record.value;
        const pValueContent = bipf.seekKey2(buf, pValue, BIPF_CONTENT, 0);
        if (pValueContent < 0)
            return;
        const pValueContentChannel = bipf.seekKey2(buf, pValueContent, BIPF_CHANNEL, 0);
        const pValueContentMentions = bipf.seekKey2(buf, pValueContent, BIPF_MENTIONS, 0);
        if (pValueContentChannel >= 0) {
            const channel = bipf.decode(buf, pValueContentChannel);
            // msg.value.content.channel typically does not have `#`
            if (channel && typeof channel === 'string') {
                const label = sanitize(channel);
                this.batch.push({
                    type: 'put',
                    key: [label, seq],
                    value: B_0,
                });
            }
        }
        if (pValueContentMentions >= 0) {
            const mentions = bipf.decode(buf, pValueContentMentions);
            if (Array.isArray(mentions)) {
                for (const { link } of mentions) {
                    // msg.value.content.mentions[].link SHOULD have `#`
                    if (link && typeof link === 'string' && link.startsWith('#')) {
                        const label = sanitize(link);
                        this.batch.push({
                            type: 'put',
                            key: [label, seq],
                            value: B_0,
                        });
                    }
                }
            }
        }
    }
    /**
     * Gets the `seq` of all messages that have *any* of the given hashtags.
     */
    getMessagesByHashtags(hashtags, live, cb, onAbort) {
        if (!hashtags || !Array.isArray(hashtags))
            return cb(null, seqs([]));
        if (live === 'liveAndOld')
            return cb(new Error('unimplemented liveAndOld'));
        const labels = hashtags.map(sanitize);
        const sortedLabels = labels.sort((a, b) => a.localeCompare(b));
        const minLabel = sortedLabels[0];
        const maxLabel = sortedLabels[sortedLabels.length - 1];
        if (live) {
            const ps = pull(pl.read(this.level, {
                gte: [minLabel, ''],
                lte: [maxLabel, undefined],
                keys: true,
                keyEncoding: this.keyEncoding,
                values: false,
                live: true,
                old: false,
            }), pull.filter(([label, _seq]) => labels.includes(label)), pull.map(([_label, seq]) => seq));
            return cb(null, liveSeqs(ps));
        }
        else {
            let drainer;
            onAbort(() => {
                drainer === null || drainer === void 0 ? void 0 : drainer.abort();
            });
            const seqArr = [];
            pull(pull.values(sortedLabels), pull.map((label) => pl.read(this.level, {
                gte: [label, ''],
                lte: [label, undefined],
                keys: true,
                keyEncoding: this.keyEncoding,
                values: false,
            })), pull.flatten(), (drainer = pull.drain(([, seq]) => seqArr.push(seq), (err) => {
                drainer = undefined;
                if (err)
                    cb(err);
                else
                    cb(null, seqs(seqArr));
            })));
        }
    }
    /**
     * Generalized version of `getMesssagesByHashtag`.
     * Gets the `seq` of all messages that have *some* hashtag.
     */
    getMessagesWithSomeHashtag(live, cb, onAbort) {
        if (live === 'liveAndOld')
            return cb(new Error('unimplemented liveAndOld'));
        const sharedReadOpts = {
            gt: ['', ''],
            lt: [undefined, undefined],
            keys: true,
            keyEncoding: this.keyEncoding,
            values: false,
        };
        if (live) {
            const ps = pull(pl.read(this.level, {
                ...sharedReadOpts,
                live: true,
                old: false,
            }), pull.map(([, seq]) => seq));
            return cb(null, liveSeqs(ps));
        }
        else {
            let drainer;
            onAbort(() => {
                drainer === null || drainer === void 0 ? void 0 : drainer.abort();
            });
            const seqArr = [];
            pull(pl.read(this.level, sharedReadOpts), (drainer = pull.drain(([, seq]) => seqArr.push(seq), (err) => {
                drainer = undefined;
                if (err)
                    cb(err);
                else
                    cb(null, seqs(seqArr));
            })));
        }
    }
    /**
     * Gets a list of hashtags of length `limit` that start with the `query`
     */
    getMatchingHashtags(query, limit, cb) {
        // hashtag -> count
        const result = new Map();
        // Upperbound is determined by replacing the last character of the query with the one whose char code is +1 greater
        const lessThan = query.slice(0, query.length - 1) +
            String.fromCharCode(query.charCodeAt(query.length - 1) + 1);
        pull(pl.read(this.level, {
            gte: [query, ''],
            lt: [lessThan, ''],
            keys: true,
            keyEncoding: this.keyEncoding,
            values: false,
        }), pull.drain(([label]) => {
            const count = result.get(label) || 0;
            result.set(label, count + 1);
        }, (err) => {
            if (err)
                cb(err);
            else {
                // Order by count from highest to lowest
                const sorted = Array.from(result.entries()).sort(([, c1], [, c2]) => c2 - c1);
                cb(null, limit > 0 ? sorted.slice(0, limit) : sorted);
            }
        }));
    }
}
exports.default = HashtagPlugin;
//# sourceMappingURL=hashtags.js.map