import { Opts, ProfileOpts, ThreadOpts, UpdatesOpts, ThreadUpdatesOpts, HashtagOpts, HashtagUpdatesOpts, HashtagsMatchingOpts, RecentHashtagsOpts } from './types';
declare type CB<T> = (err: any, val?: T) => void;
declare class threads {
    private readonly ssb;
    private readonly isBlocking;
    private readonly isFollowing;
    constructor(ssb: Record<string, any>, _config: any);
    private onlyKeepFollowingRootMessages;
    private onlyKeepMessageIfFollowingRoot;
    private removeMessagesFromBlocked;
    private removeMessagesWhereRootIsMissingOrBlocked;
    private nonBlockedRootToThread;
    private nonBlockedRootToSummary;
    /**
     * Returns a pull-stream operator that maps the source of message keys
     * to their respective root messages, if the roots are in the database.
     */
    private fetchMsgFromIdIfItExists;
    private rootToThread;
    private rootMsgIdForHashtagMatch;
    public: (opts: Opts) => any;
    publicSummary: (opts: Omit<Opts, 'threadMaxSize'>) => any;
    publicUpdates: (opts: UpdatesOpts) => any;
    hashtagCount: (opts: Omit<HashtagOpts, 'maxThreadSize' | 'reverse' | 'following'>, cb: CB<number>) => void;
    hashtagSummary: (opts: Omit<HashtagOpts, 'threadMaxSize' | 'following'>) => any;
    hashtagUpdates: (opts: HashtagUpdatesOpts) => any;
    hashtagsMatching: (opts: HashtagsMatchingOpts, cb: CB<Array<[string, number]>>) => void;
    recentHashtags: (opts: RecentHashtagsOpts, cb: CB<Array<string>>) => any;
    private: (opts: Opts) => any;
    privateUpdates: (opts: UpdatesOpts) => any;
    profile: (opts: ProfileOpts) => any;
    profileSummary: (opts: Omit<ProfileOpts, 'threadMaxSize'>) => any;
    thread: (opts: ThreadOpts) => any;
    threadUpdates: (opts: ThreadUpdatesOpts) => any;
}
export = threads;
