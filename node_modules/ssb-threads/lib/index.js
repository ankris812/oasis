"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const utils_1 = require("ssb-typescript/utils");
const secret_stack_decorators_1 = require("secret-stack-decorators");
const pull = require('pull-stream');
const cat = require('pull-cat');
const sort = require('ssb-sort');
const Ref = require('ssb-ref');
const { where, and, or, not, type, author, descending, live, batch, isPrivate, isPublic, hasRoot, hasFork, toPullStream, } = require('ssb-db2/operators');
const hashtags_1 = require("./hashtags");
const hasHashtag = hashtags_1.default.hasHashtagOperator;
const hasSomeHashtag = hashtags_1.default.hasSomeHashtagOperator;
const IS_BLOCKING_NEVER = (obj, cb) => {
    cb(null, false);
};
/**
 * 100 msgs kept in memory is rather small (~50kB), but this is large enough to
 * have good performance in JITDB pagination, see
 * https://github.com/ssb-ngi-pointer/jitdb/pull/123#issuecomment-782734363
 */
const BATCH_SIZE = 100;
function getTimestamp(msg) {
    const arrivalTimestamp = msg.timestamp;
    const declaredTimestamp = msg.value.timestamp;
    return Math.min(arrivalTimestamp, declaredTimestamp);
}
function getRootMsgId(msg) {
    var _a;
    if ((_a = msg === null || msg === void 0 ? void 0 : msg.value) === null || _a === void 0 ? void 0 : _a.content) {
        const fork = msg.value.content.fork;
        const root = msg.value.content.root;
        if (fork && Ref.isMsgId(fork))
            return fork;
        if (root && Ref.isMsgId(root))
            return root;
    }
    // this msg has no root so we assume this is a root
    return msg.key;
}
function isUniqueMsgId(uniqueRoots) {
    return function checkIsUnique_id(id) {
        if (uniqueRoots.has(id)) {
            return false;
        }
        else {
            uniqueRoots.add(id);
            return true;
        }
    };
}
function hasNoBacklinks(msg) {
    var _a, _b, _c, _d, _e, _f;
    return (!((_b = (_a = msg === null || msg === void 0 ? void 0 : msg.value) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.root) &&
        !((_d = (_c = msg === null || msg === void 0 ? void 0 : msg.value) === null || _c === void 0 ? void 0 : _c.content) === null || _d === void 0 ? void 0 : _d.branch) &&
        !((_f = (_e = msg === null || msg === void 0 ? void 0 : msg.value) === null || _e === void 0 ? void 0 : _e.content) === null || _f === void 0 ? void 0 : _f.fork));
}
function notNull(x) {
    return x !== null;
}
// Strip leading # from hashtag string
function withoutLeadingHashtag(s) {
    return s.startsWith('#') ? s.slice(1) : s;
}
function makeFilterOperator(opts) {
    if (opts.allowlist) {
        const allowedTypes = opts.allowlist.map((x) => type(x));
        return or(...allowedTypes);
    }
    if (opts.blocklist) {
        const blockedTypes = opts.blocklist.map((x) => not(type(x)));
        return and(...blockedTypes);
    }
    return null;
}
function makePassesFilter(opts) {
    if (opts.allowlist) {
        return (msg) => opts.allowlist.some((type) => { var _a, _b; return ((_b = (_a = msg === null || msg === void 0 ? void 0 : msg.value) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.type) === type; });
    }
    if (opts.blocklist) {
        return (msg) => opts.blocklist.every((type) => { var _a, _b; return ((_b = (_a = msg === null || msg === void 0 ? void 0 : msg.value) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.type) !== type; });
    }
    return () => true;
}
function assertFollowingOnlyUsability(enabled, isFollowing) {
    if (enabled && !isFollowing) {
        throw new Error('ssb-threads requires ssb-friends installed');
    }
}
let threads = class threads {
    constructor(ssb, _config) {
        var _a, _b;
        //#region PRIVATE
        // Make sure you're using this on a source that only returns root messages
        this.onlyKeepFollowingRootMessages = (isFollowing) => (source) => pull(source, pull.asyncMap((rootMsg, cb) => {
            if (rootMsg.value.author === this.ssb.id) {
                return cb(null, rootMsg);
            }
            isFollowing({ source: this.ssb.id, dest: rootMsg.value.author }, (err, following) => {
                if (err)
                    cb(err);
                else if (!following)
                    cb(null, null);
                else
                    cb(null, rootMsg);
            });
        }), pull.filter(notNull));
        this.onlyKeepMessageIfFollowingRoot = (isFollowing, includeSelf) => (source) => pull(source, pull.asyncMap((msg, cb) => {
            const rootMsgKey = getRootMsgId(msg);
            if (includeSelf && msg.value.author === this.ssb.id) {
                return cb(null, msg);
            }
            this.ssb.db.getMsg(rootMsgKey, (err, rootMsg) => {
                if (err)
                    cb(null, null);
                if (rootMsg.value.author === this.ssb.id) {
                    return cb(null, msg);
                }
                isFollowing({ source: this.ssb.id, dest: rootMsg.value.author }, (err, following) => {
                    if (err)
                        cb(err);
                    else if (!following)
                        cb(null, null);
                    else
                        cb(null, msg);
                });
            });
        }), pull.filter(notNull));
        this.removeMessagesFromBlocked = (source) => pull(source, pull.asyncMap((msg, cb) => {
            this.isBlocking({ source: this.ssb.id, dest: msg.value.author }, (err, blocking) => {
                if (err)
                    cb(err);
                else if (blocking)
                    cb(null, null);
                else
                    cb(null, msg);
            });
        }), pull.filter(notNull));
        this.removeMessagesWhereRootIsMissingOrBlocked = (passesFilter) => (source) => pull(source, pull.asyncMap((msg, cb) => {
            const rootMsgKey = getRootMsgId(msg);
            if (rootMsgKey === msg.key)
                return cb(null, msg);
            this.ssb.db.getMsg(rootMsgKey, (err, rootMsg) => {
                if (err)
                    cb(null, null);
                else if (!passesFilter(rootMsg))
                    cb(null, null);
                else {
                    this.isBlocking({ source: this.ssb.id, dest: rootMsg.value.author }, (err, blocking) => {
                        if (err)
                            cb(null, null);
                        else if (blocking)
                            cb(null, null);
                        else
                            cb(null, msg);
                    });
                }
            });
        }), pull.filter(notNull));
        this.nonBlockedRootToThread = (maxSize, filter, privately = false) => {
            return (root, cb) => {
                pull(cat([
                    pull.values([root]),
                    pull(this.ssb.db.query(where(and(hasRoot(root.key), filter, privately ? isPrivate() : isPublic())), batch(BATCH_SIZE), descending(), toPullStream()), this.removeMessagesFromBlocked, pull.take(maxSize)),
                ]), pull.take(maxSize + 1), pull.collect((err, arr) => {
                    if (err)
                        return cb(err);
                    const full = arr.length <= maxSize;
                    sort(arr);
                    if (arr.length > maxSize && arr.length >= 3)
                        arr.splice(1, 1);
                    cb(null, { messages: arr, full });
                }));
            };
        };
        this.nonBlockedRootToSummary = (filter) => {
            return (root, cb) => {
                pull(this.ssb.db.query(where(and(or(hasRoot(root.key), hasFork(root.key)), filter)), batch(BATCH_SIZE), descending(), toPullStream()), this.removeMessagesFromBlocked, pull.collect((err, arr) => {
                    if (err)
                        return cb(err);
                    const timestamp = Math.max(...arr.concat(root).map(getTimestamp));
                    cb(null, { root, replyCount: arr.length, timestamp });
                }));
            };
        };
        /**
         * Returns a pull-stream operator that maps the source of message keys
         * to their respective root messages, if the roots are in the database.
         */
        this.fetchMsgFromIdIfItExists = (source) => pull(source, pull.asyncMap((id, cb) => {
            this.ssb.db.getMsg(id, (err, msg) => {
                if (err)
                    cb(null, null /* missing msg */);
                else
                    cb(err, msg);
            });
        }), pull.filter(notNull));
        this.rootToThread = (maxSize, filter, privately) => {
            return pull.asyncMap((root, cb) => {
                this.isBlocking({ source: this.ssb.id, dest: root.value.author }, (err, blocking) => {
                    if (err) {
                        cb(err);
                    }
                    else if (blocking) {
                        cb(new Error('Author Blocked:' + root.value.author));
                    }
                    else {
                        this.nonBlockedRootToThread(maxSize, filter, privately)(root, cb);
                    }
                });
            });
        };
        this.rootMsgIdForHashtagMatch = (hashtags, opts) => {
            return pull(this.ssb.db.query(where(and(isPublic(), hasHashtag(hashtags), opts.queryFilter)), opts.needsDescending ? descending() : null, batch(BATCH_SIZE), toPullStream()), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(opts.msgPassesFilter), pull.filter(utils_1.isPublic), pull.filter(hasNoBacklinks), this.removeMessagesFromBlocked);
        };
        //#endregion
        //#region PUBLIC API
        this.public = (opts) => {
            var _a, _b, _c;
            const needsDescending = (_a = opts.reverse) !== null && _a !== void 0 ? _a : true;
            const threadMaxSize = (_b = opts.threadMaxSize) !== null && _b !== void 0 ? _b : Infinity;
            const followingOnly = (_c = opts.following) !== null && _c !== void 0 ? _c : false;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            try {
                assertFollowingOnlyUsability(followingOnly, this.isFollowing);
            }
            catch (err) {
                return pull.error(err);
            }
            return pull(this.ssb.db.query(where(and(isPublic(), filterOperator)), needsDescending ? descending() : null, batch(BATCH_SIZE), toPullStream()), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(passesFilter), pull.filter(utils_1.isPublic), pull.filter(hasNoBacklinks), this.removeMessagesFromBlocked, followingOnly
                ? this.onlyKeepFollowingRootMessages(this.isFollowing)
                : pull.through(), pull.asyncMap(this.nonBlockedRootToThread(threadMaxSize, filterOperator)));
        };
        this.publicSummary = (opts) => {
            var _a, _b;
            const needsDescending = (_a = opts.reverse) !== null && _a !== void 0 ? _a : true;
            const followingOnly = (_b = opts.following) !== null && _b !== void 0 ? _b : false;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            try {
                assertFollowingOnlyUsability(followingOnly, this.isFollowing);
            }
            catch (err) {
                return pull.error(err);
            }
            return pull(this.ssb.db.query(where(and(isPublic(), filterOperator)), needsDescending ? descending() : null, batch(BATCH_SIZE), toPullStream()), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(passesFilter), pull.filter(utils_1.isPublic), pull.filter(hasNoBacklinks), this.removeMessagesFromBlocked, followingOnly
                ? this.onlyKeepFollowingRootMessages(this.isFollowing)
                : pull.through(), pull.asyncMap(this.nonBlockedRootToSummary(filterOperator)));
        };
        this.publicUpdates = (opts) => {
            var _a, _b;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            const includeSelf = (_a = opts.includeSelf) !== null && _a !== void 0 ? _a : false;
            const followingOnly = (_b = opts.following) !== null && _b !== void 0 ? _b : false;
            try {
                assertFollowingOnlyUsability(followingOnly, this.isFollowing);
            }
            catch (err) {
                return pull.error(err);
            }
            return pull(this.ssb.db.query(where(and(isPublic(), filterOperator, includeSelf ? null : not(author(this.ssb.id, { dedicated: true })))), live({ old: false }), toPullStream()), this.removeMessagesFromBlocked, this.removeMessagesWhereRootIsMissingOrBlocked(passesFilter), followingOnly
                ? this.onlyKeepMessageIfFollowingRoot(this.isFollowing, includeSelf)
                : pull.through(), pull.map((msg) => msg.key));
        };
        this.hashtagCount = (opts, cb) => {
            if (!opts.hashtag || typeof opts.hashtag !== 'string') {
                cb(new Error('opts.hashtag is required'));
                return;
            }
            pull(this.rootMsgIdForHashtagMatch([opts.hashtag], {
                needsDescending: false,
                msgPassesFilter: makePassesFilter(opts),
                queryFilter: makeFilterOperator(opts),
            }), pull.reduce((count) => count + 1, 0, cb));
        };
        this.hashtagSummary = (opts) => {
            var _a;
            const filterOperator = makeFilterOperator(opts);
            let hashtags = null;
            if (opts.hashtags && Array.isArray(opts.hashtags)) {
                if (opts.hashtags.length === 0) {
                    return pull.error(new Error('opts.hashtags must have at least one'));
                }
                if (opts.hashtags.some((h) => !h || typeof h !== 'string')) {
                    return pull.error(new Error('opts.hashtags must be an array of strings, but got: ' +
                        opts.hashtags));
                }
                hashtags = opts.hashtags;
            }
            else if (opts.hashtag && typeof opts.hashtag === 'string') {
                hashtags = [opts.hashtag];
            }
            else {
                return pull.error(new Error('opts.hashtag or opts.hashtags is required'));
            }
            return pull(this.rootMsgIdForHashtagMatch(hashtags, {
                needsDescending: (_a = opts.reverse) !== null && _a !== void 0 ? _a : true,
                msgPassesFilter: makePassesFilter(opts),
                queryFilter: filterOperator,
            }), pull.asyncMap(this.nonBlockedRootToSummary(filterOperator)));
        };
        this.hashtagUpdates = (opts) => {
            const filterOperator = makeFilterOperator(opts);
            let hashtags = null;
            if (opts.hashtags && Array.isArray(opts.hashtags)) {
                if (opts.hashtags.length === 0) {
                    return pull.error(new Error('opts.hashtags must have at least one'));
                }
                if (opts.hashtags.some((h) => !h || typeof h !== 'string')) {
                    return pull.error(new Error('opts.hashtags must be an array of strings, but got: ' +
                        opts.hashtags));
                }
                hashtags = opts.hashtags;
            }
            else if (opts.hashtag && typeof opts.hashtag === 'string') {
                hashtags = [opts.hashtag];
            }
            else {
                return pull.error(new Error('opts.hashtag or opts.hashtags is required'));
            }
            return pull(this.ssb.db.query(where(and(isPublic(), hasHashtag(hashtags), filterOperator)), live({ old: false }), toPullStream()), this.removeMessagesFromBlocked, pull.map(getRootMsgId));
        };
        this.hashtagsMatching = (opts, cb) => {
            if (typeof opts.query !== 'string' || opts.query.length === 0)
                return cb(new Error('opts.query must be non-empty string'));
            if (opts.limit && opts.limit <= 0)
                return cb(new Error('opts.limit must be number greater than 0'));
            const query = opts.query.toLocaleLowerCase();
            const limit = opts.limit || 10;
            this.ssb.db.onDrain('hashtags', () => {
                const hashtagsPlugin = this.ssb.db.getIndex('hashtags');
                hashtagsPlugin.getMatchingHashtags(query, limit, cb);
            });
        };
        this.recentHashtags = (opts, cb) => {
            if (typeof opts.limit !== 'number' || opts.limit <= 0)
                return cb(new Error('Limit must be number greater than 0'));
            const preserveCase = !!opts.preserveCase;
            // completely normalized hashtag (no leading # and lowercase) -> partially normalized (no leading #)
            const result = new Map();
            return pull(this.ssb.db.query(where(and(isPublic(), hasSomeHashtag())), descending(), batch(BATCH_SIZE), toPullStream()), this.removeMessagesFromBlocked, pull.through((msg) => {
                const { channel, mentions } = msg.value.content;
                if (channel) {
                    const withoutHashtag = withoutLeadingHashtag(channel);
                    const lowercaseWithoutHashtag = withoutHashtag.toLocaleLowerCase();
                    // Since the messages received are descending,
                    // we don't want to update the value for
                    // associated key if it already exists
                    // because we want the keep the most recent
                    // variation of the hashtag (accounts for casing)
                    if (!result.has(lowercaseWithoutHashtag)) {
                        result.set(lowercaseWithoutHashtag, withoutHashtag);
                    }
                }
                else if (Array.isArray(mentions)) {
                    for (const { link } of mentions) {
                        // msg.value.content.mentions[].link SHOULD have `#`
                        if (link && typeof link === 'string' && link.startsWith('#')) {
                            const withoutHashtag = withoutLeadingHashtag(link);
                            const lowercaseWithoutHashtag = withoutHashtag.toLocaleLowerCase();
                            // Since the messages received are descending,
                            // we don't want to update the value for
                            // associated key if it already exists
                            // because we want the keep the most recent
                            // variation of the hashtag (accounts for casing)
                            if (!result.has(lowercaseWithoutHashtag)) {
                                result.set(lowercaseWithoutHashtag, withoutHashtag);
                            }
                            if (result.size === opts.limit)
                                break;
                        }
                    }
                }
            }), 
            // Keep taking values until the result size === limit
            pull.take(() => result.size < opts.limit), pull.onEnd(() => {
                cb(null, Array.from(preserveCase ? result.values() : result.keys()));
            }));
        };
        this.private = (opts) => {
            var _a, _b;
            const needsDescending = (_a = opts.reverse) !== null && _a !== void 0 ? _a : true;
            const threadMaxSize = (_b = opts.threadMaxSize) !== null && _b !== void 0 ? _b : Infinity;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            return pull(this.ssb.db.query(where(and(isPrivate(), filterOperator)), needsDescending ? descending() : null, batch(BATCH_SIZE), toPullStream()), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(passesFilter), pull.filter(utils_1.isPrivate), pull.filter(hasNoBacklinks), this.removeMessagesFromBlocked, pull.asyncMap(this.nonBlockedRootToThread(threadMaxSize, filterOperator, true)));
        };
        this.privateUpdates = (opts) => {
            var _a;
            const filterOperator = makeFilterOperator(opts);
            const includeSelf = (_a = opts.includeSelf) !== null && _a !== void 0 ? _a : false;
            return pull(this.ssb.db.query(where(and(isPrivate(), filterOperator, includeSelf ? null : not(author(this.ssb.id, { dedicated: true })))), live({ old: false }), toPullStream()), this.removeMessagesFromBlocked, pull.map(getRootMsgId));
        };
        this.profile = (opts) => {
            var _a, _b;
            const id = opts.id;
            const needsDescending = (_a = opts.reverse) !== null && _a !== void 0 ? _a : true;
            const threadMaxSize = (_b = opts.threadMaxSize) !== null && _b !== void 0 ? _b : Infinity;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            return pull(this.ssb.db.query(where(and(author(id), isPublic(), filterOperator)), needsDescending ? descending() : null, batch(BATCH_SIZE), toPullStream()), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(passesFilter), pull.filter(utils_1.isPublic), this.removeMessagesFromBlocked, pull.asyncMap(this.nonBlockedRootToThread(threadMaxSize, filterOperator)));
        };
        this.profileSummary = (opts) => {
            var _a;
            const id = opts.id;
            const needsDescending = (_a = opts.reverse) !== null && _a !== void 0 ? _a : true;
            const filterOperator = makeFilterOperator(opts);
            const passesFilter = makePassesFilter(opts);
            return pull(this.ssb.db.query(where(and(author(id), isPublic(), filterOperator)), needsDescending ? descending() : null, batch(BATCH_SIZE), toPullStream()), pull.map(getRootMsgId), pull.filter(isUniqueMsgId(new Set())), this.fetchMsgFromIdIfItExists, pull.filter(passesFilter), pull.filter(utils_1.isPublic), pull.filter(hasNoBacklinks), this.removeMessagesFromBlocked, pull.asyncMap(this.nonBlockedRootToSummary(filterOperator)));
        };
        this.thread = (opts) => {
            var _a;
            const privately = !!opts.private;
            const threadMaxSize = (_a = opts.threadMaxSize) !== null && _a !== void 0 ? _a : Infinity;
            const optsOk = !opts.allowlist && !opts.blocklist
                ? { ...opts, allowlist: ['post'] }
                : opts;
            const filterOperator = makeFilterOperator(optsOk);
            return pull(pull.values([opts.root]), this.fetchMsgFromIdIfItExists, privately ? pull.through() : pull.filter(utils_1.isPublic), this.rootToThread(threadMaxSize, filterOperator, privately));
        };
        this.threadUpdates = (opts) => {
            const privately = !!opts.private;
            const filterOperator = makeFilterOperator(opts);
            return pull(this.ssb.db.query(where(and(hasRoot(opts.root), filterOperator, privately ? isPrivate() : isPublic())), live({ old: false }), toPullStream()), this.removeMessagesFromBlocked);
        };
        this.ssb = ssb;
        this.isBlocking = ((_a = ssb.friends) === null || _a === void 0 ? void 0 : _a.isBlocking)
            ? ssb.friends.isBlocking
            : IS_BLOCKING_NEVER;
        this.isFollowing = (_b = ssb.friends) === null || _b === void 0 ? void 0 : _b.isFollowing;
        this.ssb.db.registerIndex(hashtags_1.default);
    }
};
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "public", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "publicSummary", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "publicUpdates", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('async')
], threads.prototype, "hashtagCount", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "hashtagSummary", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "hashtagUpdates", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('async')
], threads.prototype, "hashtagsMatching", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('async')
], threads.prototype, "recentHashtags", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "private", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "privateUpdates", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "profile", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "profileSummary", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "thread", void 0);
__decorate([
    (0, secret_stack_decorators_1.muxrpc)('source')
], threads.prototype, "threadUpdates", void 0);
threads = __decorate([
    (0, secret_stack_decorators_1.plugin)('2.0.0')
], threads);
module.exports = threads;
//# sourceMappingURL=index.js.map
