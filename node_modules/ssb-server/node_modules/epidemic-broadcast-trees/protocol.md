
# epidemic-broadcast-trees

epidemic-broadcast-trees is implemented in terms of
a data structure which represents the state of a peer,
and events which transition that state.
Given an implementation of this structure and
events, that implementation needs only trivial glue
to become a fully valid implementation.

## data structure

exposed as `ebt.state` (copied from readme)

```
{
  id: <id>, //our id,
  clock: {<id>: <seq>}, //our local clock,
  follows: {<id>: <boolean>}, //who we replicate, true if we replicate.
  blocks: {<id>: {<id>: <boolean>}}, //who blocks who, true if they are blocked.
  peers: { //currently connected peers
    <id>: {
      clock: {<id>: <seq|-1>}, //feeds that we KNOW the peer is up to. -1 if they do not replicate that feed.
      msgs: [<msg>], //queue of messages waiting to be sent.
      retrive: [<seq>], //sequence numbers of messages to look up in our database.
      notes: null || {<id>: <encoded_seq>}, //notes object (encoded vector clock to be sent)
      replicating: { //feeds being replicated to peer.
        <id>: {
          rx: <boolean>,
          tx: <boolean>,
          sent: <seq|-1|null>, //sequence number of message we sent.
          requested: <seq|-1|null> //sequence number we asked for.
        }
      }
    }
  },
  receive: [<msg>] //queue of incoming messages
}
```

## events

### clock

our own clock (`state.clock`) has been loaded.

* precondition: `state.clock == null`
* postcondition: `isVectorClock(state.clock)`

### connect

* precondition: `state.peers[ev.id] == null` not already connected.
//* postconditions: `state.peers[ev.id].blocked = state.blocked[state.id][ev.id]
