{
  "name": "secret-handshake",
  "description": "a simple and highly private secure-channel protocol",
  "version": "1.1.21",
  "homepage": "https://github.com/auditdrivencrypto/secret-handshake",
  "repository": {
    "type": "git",
    "url": "git://github.com/auditdrivencrypto/secret-handshake.git"
  },
  "files": [
    "*.js"
  ],
  "dependencies": {
    "chloride": "^2.2.8",
    "clarify-error": "^1.0.0",
    "pull-box-stream": "^1.0.13",
    "pull-handshake": "^1.1.1",
    "pull-stream": "^3.4.5"
  },
  "devDependencies": {
    "npm-run-all": "^4.1.5",
    "pull-bitflipper": "~0.1.0",
    "pull-defer": "^0.2.2",
    "pull-hang": "0.0.0",
    "shs1-test": "^1.1.0",
    "stream-to-pull-stream": "^1.7.3",
    "tape": "^4.10.1",
    "test-secret-handshake": "^1.0.0"
  },
  "author": "Dominic Tarr <dominic.tarr@gmail.com> (http://dominictarr.com)",
  "license": "MIT",
  "scripts": {
    "test": "npm-run-all test:original test:shs1-test",
    "test:original": "set -e; for t in test/*.js; do node $t; done",
    "test:shs1-test": "npm-run-all test:shs1-test:*",
    "test:shs1-test:server": "shs1testserver test/shs1-test/server.js",
    "test:shs1-test:client": "shs1testclient test/shs1-test/client.js"
  },
  "readme": "# secret-handshake\n\nsecure-channel based on a a mutually authenticating key agreement handshake, with forward secure identity metadata.\n\nFor a full explanation of the design, read the\n[Design Paper](http://dominictarr.github.io/secret-handshake-paper/shs.pdf)\n\n## Implementations\n\n* javascript/node.js this repo.\n* go [cryptix/secretstream](https://github.com/cryptix/secretstream/)\n* rust [AljoschaMeyer/secret-handshake-rs](https://github.com/AljoschaMeyer/secret-handshake-rs)\n* c [AljoschaMeyer/shs1-c](https://github.com/AljoschaMeyer/shs1-c) (actually just implements the crypto, not the protocol used as a component in the rust implementation)\n* python/twisted [david415/txsecrethandshake](https://github.com/david415/txsecrethandshake) (WIP)\n* C++ [Kodest/cppshs](https://github.com/Kodest/cppshs) (WIP)\n* also [keks/tamarin-shs](https://github.com/keks/tamarin-shs) is a formal proof of the cryptographic properties!\n\n## Claims\n\nThis protocol derives shared keys and mutually\nauthenticates both ends of the connection.\nThe shared secrets are forward secure, and\nso is the identity metadata.\n\nby \"forward secure identity metadata\" I mean:\n\n* a later key compromise cannot confirm the public keys in the handshake.\n\nAnd also:\n\n* an eavesdropper cannot learn public keys\n* replay attacker cannot learn public keys.\n* man in the middle cannot learn public keys.\n* a \"wrong number\" cannot learn public keys.\n* an unauthenticated client cannot learn server key.\n  \n> note: a wrong number is just an accidental man in the middle.\n\nBy \"confirm\" I mean check a guess at the public key.\nBy \"learn\" I mean that you can _either_ extract the public key,\nor confirm the public key.\n\nAlso note that if the server decides not to authenticate a client,\nit will learn their public key. To get to this stage, the client\nmust know the server's key, so now the client and server both\nknow each others key. This is fair.\n\n## Disclaims\n\nThis protocol cannot hide your ip address.\nThis protocol does not attempt to obscure packet boundries.\nIf a man in the middle or wrong number later compromises\nthe server's key, they will be able to extract the client\nkey from the client's hello packet.\n\n## Example\n\n``` js\nvar SHS = require('secret-handshake')\n\nvar cl = require('chloride')\nvar appKey = ... //32 random bytes\nvar alice = cl.crypto_sign_keypair() //client\nvar bob = cl.crypto_sign_keypair()   //server\n\nfunction authorize(id, cb) {\n  cb(null, check(id)) //check wether id is authorized.\n}\n\n//initialize, with default timeouts.\nvar ServerStream = SHS.createServer(alice, authorize, appKey)\nvar ClientStream = SHS.createClient(bob, appkey)\n\nvar alice_stream = ServerStream(function (err, stream) {\n  ...\n})\n\nvar bob_stream = ClientStream(alice.publicKey, function (err, stream) {\n  ...\n})\n\n//simulate a streaming network connection by connecting streams together\npull(alice_stream, bob_stream, alice_stream)\n```\n\n## Notes\n\nI recommend using secret-handshake via [multiserver](https://github.com/dominictarr/multiserver)\n\n[pull-streams](https://github.com/dominictarr/pull-streams) are used.\nLearn about how pull-streams from [these examples](https://github.com/dominictarr/pull-stream-examples)\n\nKeypairs are expected to be of the form [sodium](https://github.com/paixaop/node-sodium) produces.\n[chloride](https://github.com/dominictarr/chloride) is my fork of this and is compatible.\n\nIf you're interested in the protocol, you can read more here : https://ssbc.github.io/scuttlebutt-protocol-guide/#handshake\n\n## api\n\n### createClient(keypair, authorize, appkey, timeout) => createClientStream(key, seed?, cb(err, plainstream)) => cipherstream\n\n`createClient` takes: \n- `keypair` - a keypair of form `{ secretKey, publicKey }` - your clients keys (see `chloride#crypto_sign_keypair`)\n- `appkey` - the network identifier, 32 random bytes\n- `timeout` - an integer (in milliseconds? CHECK THIS)\n\nand returns a `createClientStream`\n\n`createClientStream` takes a the public `key` for the remote peer,\nan optional `seed` (which is used to generate a one-time private key),\nand a callback, `cb`. `cipherstream`, an encrypted duplex pull-stream is returned.\n\nOnce the stream is connected to a server stream,\nsecret-handshake will attempt to authorize, and will call\n`cb` with an `err` if it fails, or `plainstream` if it succeeds.\nIf `keypair` is null, `seed` *must* be provided.\n\n### createServer(keypair, authorize(id, cb), appkey, timeout) => createServerStream(cb(err, plain_stream)) => cipherstream\n\n`createServer` is similar, except it takes `authorize`,\n- `keypair` - a keypair of form `{ secretKey, publicKey }` (see `chloride#crypto_sign_keypair`)\n- `authorize` - an async function of signature `(id, cb)` that decides whether a client with id == publicKey is allowed to continue with handshake\n- `appkey` - the network identifier, 32 random bytes\n- `timeout` - an integer (in milliseconds? CHECK THIS)\n\nA stream constructor function is returned\nNote the server DOES NOT take the client id as an argument - instead, in the process\nof the handshake, the server learns the `id`, and passes it to `authorize`.\nIf `authorize` calls back truthy, then it will callback `cb(null, plainstream)`\nelse it errors, `cb(err)`.\nThe value that `authorize` calls back `cb(null, <V>)` will be assigned to `plainstream.auth = <V>`.\nAlso, the `id` of the remote will be assigned to `plainstream.id`.\nThis way the application layer can know who it's peer is.\n\n## License\n\nMIT\n"
}